#!/usr/bin/env bash
# symlinkit - A flexible symlink helper with fzf + dry-run support
#
# 📌 Usage:
#   symlinkit [FLAGS] [SOURCE] [DESTINATION]
#
# 🔑 Flags:
#   -o                     Overwrite mode (remove existing target, replace with symlink)
#   -m                     Merge mode (recursively symlink contents into destination)
#   --dry-run              Preview actions (conflicts default to "skip")
#   --dry-run-overwrite    Preview actions (conflicts default to "overwrite")
#   --tree                 Minimal tree view (standalone or after linking)
#   --tree-verbose         Verbose tree view with permissions (standalone or after linking)
#
#   --list [DIR]           List symlinks (interactive if no dir given)
#   --list-verbose [DIR]   List symlinks with permissions (interactive if no dir given)
#   --broken [DIR]         List only broken symlinks (interactive if no dir given)
#   --fix-broken [DIR]     Interactively fix broken symlinks (interactive if no dir given)
#   --count-only [DIR]     Show only the count of symlinks (interactive if no dir given)
#   --depth N              Limit tree/fix-broken depth (default: 3)
#   --sort [path|target]   Sort results by path or target
#   --json                 Output results in JSON format
#
#   --fzf                  Force fzf usage (error if not installed)
#   --no-fzf               Disable fzf, use manual prompts only
#
#   -h, --help             Show help message
#   -v, --version          Show version info
#
VERSION="1.5.0"

# --- Detect OS (Linux, macOS, WSL) ---
case "$(uname -s)" in
  Linux*)   OS="Linux" ;;
  Darwin*)  OS="macOS" ;;
  CYGWIN*|MINGW*|MSYS*) OS="WindowsLike" ;;
  *)        OS="Unknown" ;;
esac

IS_WSL=false
if [[ "$OS" == "Linux" ]] && { [[ -n "${WSL_DISTRO_NAME:-}" ]] || grep -qiE "(microsoft|wsl)" /proc/version 2>/dev/null; }; then
  IS_WSL=true
fi

# --- fzf Detection ---
has_fzf() { command -v fzf >/dev/null 2>&1; }

# --- Colors ---
PATH_COLOR="\033[0;36m"
TARGET_COLOR="\033[0;35m"
RED="\033[0;31m"
YELLOW="\033[0;33m"
GREEN="\033[0;32m"
RESET="\033[0m"

# --- Helpers ---
# Error reporting and exit function
die() { echo -e "$@" >&2; exit 1; }

# Cross-platform path resolution with WSL and macOS support
realpath_wrap() {
  local p="$1"
  if [[ "$p" == "~"* ]]; then p="${p/#\~/$HOME}"; fi
  if $IS_WSL && [[ "$p" =~ ^[A-Za-z]:\\|\\|/mnt/[a-z]/ ]]; then
    if command -v wslpath >/dev/null 2>&1; then
      p="${p//\\/\/}"; wslpath -u "$p"; return
    fi
  fi
  if command -v realpath >/dev/null 2>&1; then realpath -m -- "$p"
  elif [[ "$OS" == "macOS" ]] && command -v grealpath >/dev/null 2>&1; then grealpath -m -- "$p"
  elif command -v python3 >/dev/null 2>&1; then python3 -c "import os,sys; print(os.path.realpath(sys.argv[1]))" "$p"
  else die "❌ Could not resolve path '$p'."; fi
}

# Cross-platform find wrapper (uses gfind on macOS if available)
find_wrap() {
  if [[ "$OS" == "macOS" ]] && command -v gfind >/dev/null 2>&1; then gfind "$@"
  else find "$@"; fi
}

trap "echo; die '❌ Cancelled by user'" SIGINT

# Check for permission errors and display warning
check_permission_errors() {
  local output="$1"
  local permission_errors
  permission_errors=$(echo "$output" | grep "Permission denied" || true)
  if [[ -n "$permission_errors" ]]; then
    echo "⚠️ Warning: Some directories could not be scanned due to permissions. Results may be incomplete." >&2
    return 0  # Has permission errors
  fi
  return 1  # No permission errors
}

# Safe find wrapper that handles permission errors consistently
safe_find() {
  local find_output
  find_output=$(find_wrap "$@" 2>&1)

  # Check for permission errors and warn if found
  local has_permission_errors=false
  if check_permission_errors "$find_output"; then has_permission_errors=true; fi

  # Filter out permission denied errors and return clean results
  echo "$find_output" | grep -v "Permission denied"

  # Return status indicates if there were permission errors
  if $has_permission_errors; then return 0; else return 1; fi
}

# Safe find wrapper for null-separated output (used in merge mode)
safe_find_print0() {
  local find_output
  find_output=$(find_wrap "$@" 2>&1)

  # Check for permission errors and warn if found
  local has_permission_errors=false
  if check_permission_errors "$find_output"; then has_permission_errors=true; fi

  # Filter out permission denied errors and return clean results
  # Note: find -print0 produces null-separated output, so we preserve that
  echo "$find_output" | grep -v "Permission denied"

  # Return status indicates if there were permission errors
  if $has_permission_errors; then return 0; else return 1; fi
}

# --- Modes ---
dry_run=false
dry_run_overwrite=false
mode=""
show_tree=false
show_tree_verbose=false
list_mode=false
list_verbose_mode=false
broken_mode=false
count_only=false
json=false
sort_by=""
depth=3
fix_broken=false
force_fzf=false
force_no_fzf=false

linked=0
overwritten=0
skipped=0

# --- Parse Flags ---
while [[ $# -gt 0 && "$1" == -* ]]; do
  case "$1" in
    --dry-run) dry_run=true ;;
    --dry-run-overwrite) dry_run=true; dry_run_overwrite=true ;;
    --tree) show_tree=true ;;
    --tree-verbose) show_tree_verbose=true ;;
    -o) mode="overwrite" ;;
    -m) mode="merge" ;;
    --list) list_mode=true ;;
    --list-verbose) list_verbose_mode=true ;;
    --broken) broken_mode=true ;;
    --count-only) count_only=true ;;
    --json) json=true ;;
    --sort) shift; sort_by="$1" ;;
    --depth) shift; depth="$1" ;;
    --fix-broken) fix_broken=true ;;
    --fzf) force_fzf=true ;;
    --no-fzf) force_no_fzf=true ;;
    -h|--help) grep '^# ' "$0" | sed 's/^# //' ; exit 0 ;;
    -v|--version) echo "symlinkit $VERSION ($OS${IS_WSL:++WSL})"; exit 0 ;;
    *) die "❌ Unknown flag: $1" ;;
  esac; shift
done

# If --json is specified without any mode, default to list mode
if $json && ! $list_mode && ! $list_verbose_mode && ! $broken_mode && ! $count_only && ! $show_tree && ! $show_tree_verbose && ! $fix_broken; then
  list_mode=true
fi

# Validate fzf flags
if $force_fzf && $force_no_fzf; then
  die "❌ Cannot use both --fzf and --no-fzf flags together"
fi

if $force_fzf && ! has_fzf; then
  die "❌ fzf not found but --fzf flag was specified. Install with your package manager."
fi

# --- Helpers ---
# Determine if we should use fzf for interactive selection
use_fzf() {
  if $force_no_fzf; then return 1; fi
  if $force_fzf; then return 0; fi
  has_fzf
}

# Manual directory selection fallback
manual_select_directory() {
  local search_path="$1"
  local mindepth="${2:-0}"
  local maxdepth="${3:-5}"
  local prompt="${4:-Specify a directory}"

  while true; do
    printf "%s: " "$prompt" >&2
    if ! read -r dir_input; then
      echo >&2
      echo "❌ No input received" >&2
      return 1
    fi

    if [[ -z "$dir_input" ]]; then
      echo "❌ Please enter a directory path" >&2
      continue
    fi

    # Handle tilde expansion
    if [[ "$dir_input" == "~"* ]]; then
      dir_input="${dir_input/#\~/$HOME}"
    fi

    # Convert to absolute path
    dir_input=$(realpath_wrap "$dir_input" 2>/dev/null || echo "$dir_input")

    if [[ -d "$dir_input" ]]; then
      echo "$dir_input"
      return 0
    else
      echo "❌ Directory '$dir_input' does not exist. Please try again." >&2
    fi
  done
}

# Manual file selection fallback
manual_select_file() {
  local search_path="$1"
  local prompt="${2:-Specify a file}"

  while true; do
    printf "%s: " "$prompt" >&2
    if ! read -r file_input; then
      echo >&2
      echo "❌ No input received" >&2
      return 1
    fi

    if [[ -z "$file_input" ]]; then
      echo "❌ Please enter a file path" >&2
      continue
    fi

    # Handle tilde expansion
    if [[ "$file_input" == "~"* ]]; then
      file_input="${file_input/#\~/$HOME}"
    fi

    # Convert to absolute path
    file_input=$(realpath_wrap "$file_input" 2>/dev/null || echo "$file_input")

    if [[ -f "$file_input" ]]; then
      echo "$file_input"
      return 0
    else
      echo "❌ File '$file_input' does not exist. Please try again." >&2
    fi
  done
}

# Hybrid directory selection (fzf or manual)
select_directory() {
  local search_path="$1"
  local mindepth="${2:-0}"
  local maxdepth="${3:-5}"
  local prompt="${4:-Select a directory}"

  if use_fzf; then
    find_wrap "$search_path" -mindepth "$mindepth" -maxdepth "$maxdepth" -type d 2>/dev/null \
      | fzf --prompt="$prompt > " --preview 'ls -la --color=always {}' --preview-window=down:15
  else
    # Convert "Select" to "Specify" for manual input
    local manual_prompt="${prompt/Select/Specify}"
    manual_select_directory "$search_path" "$mindepth" "$maxdepth" "$manual_prompt"
  fi
}

# Hybrid file selection (fzf or manual)
select_file() {
  local search_path="$1"
  local prompt="${2:-Select a file}"

  if use_fzf; then
    find_wrap "$search_path" -type f 2>/dev/null | fzf --prompt="$prompt > "
  else
    # Convert "Select" to "Specify" for manual input
    local manual_prompt="${prompt/Select/Specify}"
    manual_select_file "$search_path" "$manual_prompt"
  fi
}

sort_results() {
  case "$sort_by" in
    path) sort ;;
    target) awk -F' -> ' '{print $2, $0}' | sort | cut -d' ' -f2- ;;
    *) cat ;;
  esac
}
print_symlink() {
  local path="$1" target="$2"
  # Only resolve target if it's not already an absolute path
  # For relative symlink targets, resolve them relative to the symlink's directory
  if [[ -n "$target" && "$target" != /* ]]; then
    local symlink_dir="$(dirname "$path")"
    target=$(cd "$symlink_dir" && realpath_wrap "$target" 2>/dev/null || echo "$target")
  fi
  echo -e "${PATH_COLOR}${path}${RESET} -> ${TARGET_COLOR}${target}${RESET}"
}
print_symlink_verbose() { ls -l "$1"; }
print_symlink_json() {
  local path="$1" target="$2"
  # Only resolve target if it's not already an absolute path
  # For relative symlink targets, resolve them relative to the symlink's directory
  if [[ -n "$target" && "$target" != /* ]]; then
    local symlink_dir="$(dirname "$path")"
    target=$(cd "$symlink_dir" && realpath_wrap "$target" 2>/dev/null || echo "$target")
  fi
  printf '{"path":"%s","target":"%s"}\n' "$path" "$target"
}

# --- List / List-Verbose ---
if [[ "$list_mode" == true || "$list_verbose_mode" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    prompt="Select a directory to list symlinks"
    [[ "$list_verbose_mode" == true ]] && prompt+=" (verbose)"
    dir=$(select_directory "$HOME" 0 5 "$prompt")
    [[ -z "$dir" ]] && die "❌ No directory selected."
  fi
  list_output=$(find_wrap "$dir" -type l 2>&1)
  has_permission_errors=false
  if check_permission_errors "$list_output"; then has_permission_errors=true; fi
  symlinks=$(echo "$list_output" | grep -v "Permission denied")
  count=$(echo "$symlinks" | wc -l)
  [[ "$count" -eq 0 ]] && {
    if $has_permission_errors; then
      echo "⚠️ Could not scan all directories due to permissions. No symlinks found in accessible areas."
    else
      echo "❌ No symlinks found in this directory"
    fi
    exit 0
  }
  if $json; then
    if command -v jq >/dev/null 2>&1; then
      echo "$symlinks" | while read -r l; do print_symlink_json "$l" "$(readlink "$l")"; done | sort_results | jq -s .
    else
      echo "["
      echo "$symlinks" | while read -r l; do print_symlink_json "$l" "$(readlink "$l")"; done | sort_results | sed '$!s/$/,/'
      echo "]"
    fi
  else
    if [[ "$count" -eq 1 ]]; then
      echo -e "📊 Found ${GREEN}1${RESET} symlink in ${TARGET_COLOR}${dir}${RESET}:"
    else
      echo -e "📊 Found ${GREEN}${count}${RESET} symlinks in ${TARGET_COLOR}${dir}${RESET}:"
    fi
    if [[ "$list_verbose_mode" == true ]]; then
      echo "$symlinks" | while read -r l; do print_symlink_verbose "$l"; done | sort_results
    else
      echo "$symlinks" | while read -r l; do print_symlink "$l" "$(readlink "$l")"; done | sort_results
    fi
  fi; exit 0
fi

# --- Broken ---
if [[ "$broken_mode" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    dir=$(select_directory "$HOME" 0 5 "Select a directory to check for broken symlinks")
    [[ -z "$dir" ]] && die "❌ No directory selected."
  fi
  broken_output=$(find_wrap "$dir" -type l 2>&1)
  has_permission_errors=false
  if check_permission_errors "$broken_output"; then has_permission_errors=true; fi
  broken_symlinks=$(echo "$broken_output" | grep -v "Permission denied" | while read -r l; do [[ ! -e "$l" ]] && echo "$l"; done)
  broken_count=$(echo "$broken_symlinks" | wc -l)
  if [[ "$broken_count" -eq 0 ]]; then
    if $has_permission_errors; then
      echo "⚠️ Could not scan all directories due to permissions. No broken symlinks found in accessible areas."
    else
      echo "✅ You're good, no broken symlinks found in $dir"
    fi
    exit 0
  fi
  if $json; then
    if command -v jq >/dev/null 2>&1; then
      echo "$broken_symlinks" | while read -r l; do print_symlink_json "$l" "$(readlink "$l")"; done | sort_results | jq -s .
    else
      echo "["
      echo "$broken_symlinks" | while read -r l; do print_symlink_json "$l" "$(readlink "$l")"; done | sort_results | sed '$!s/$/,/'
      echo "]"
    fi
  else
    if [[ "$broken_count" -eq 1 ]]; then
      echo -e "📊 Found ${GREEN}1${RESET} broken symlink in ${TARGET_COLOR}${dir}${RESET}"
    else
      echo -e "📊 Found ${GREEN}${broken_count}${RESET} broken symlinks in ${TARGET_COLOR}${dir}${RESET}"
    fi
    echo "$broken_symlinks" | while read -r l; do print_symlink "$l" "$(readlink "$l")"; done | sort_results
  fi
  exit 0
fi

# --- Count Only ---
if [[ "$count_only" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    dir=$(select_directory "$HOME" 0 5 "Select a destination directory to count symlinks")
    [[ -z "$dir" ]] && die "❌ No directory selected."
  fi
  count_output=$(find_wrap "$dir" -type l 2>&1)
  has_permission_errors=false
  if check_permission_errors "$count_output"; then has_permission_errors=true; fi
  count=$(echo "$count_output" | grep -c -v "Permission denied")
  if $json; then
    printf '{"directory":"%s","count":%d}\n' "$dir" "$count"
  else
    if [[ "$count" -eq 1 ]]; then
      echo -e "🔢 ${GREEN}1${RESET} symlink in ${TARGET_COLOR}${dir}${RESET}"
    else
      echo -e "🔢 ${GREEN}${count}${RESET} symlinks in ${TARGET_COLOR}${dir}${RESET}"
    fi
  fi
  exit 0
fi

# --- Tree / Tree-Verbose ---
if [[ "$show_tree" == true || "$show_tree_verbose" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    prompt="Select a directory to display tree"
    [[ "$show_tree_verbose" == true ]] && prompt+=" (verbose)"
    dir=$(select_directory "$HOME" 0 5 "$prompt")
    [[ -z "$dir" ]] && die "❌ No directory selected."
  fi
  if command -v tree >/dev/null 2>&1; then
    if [[ "$show_tree_verbose" == true ]]; then
      echo "📂 Tree view of $dir (verbose, depth=$depth):"; tree -L "$depth" -F -p "$dir"
    else
      echo "📂 Tree view of $dir (depth=$depth):"; tree -L "$depth" -F "$dir"
    fi
  else
    echo "⚠️ tree not found, falling back to flat symlink list."
    tree_output=$(find_wrap "$dir" -maxdepth "$depth" -type l 2>&1)
    check_permission_errors "$tree_output" >/dev/null || true  # Just show warning, don't store result
    echo "$tree_output" | grep -v "Permission denied" | while read -r l; do print_symlink "$l" "$(readlink "$l")"; done | sort_results
  fi; exit 0
fi

# --- Fix Broken ---
if [[ "$fix_broken" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    dir=$(select_directory "$HOME" 0 5 "Select a directory to fix broken symlinks")
    [[ -z "$dir" ]] && die "❌ No directory selected."
  fi
  fix_output=$(find_wrap "$dir" -type l 2>&1)
  has_permission_errors=false
  if check_permission_errors "$fix_output"; then has_permission_errors=true; fi
  mapfile -t broken_links < <(echo "$fix_output" | grep -v "Permission denied" | while read -r l; do [[ ! -e "$l" ]] && echo "$l"; done)
  if [[ "${#broken_links[@]}" -eq 0 ]]; then
    if $has_permission_errors; then
      echo "⚠️ Could not scan all directories due to permissions. No broken symlinks found in accessible areas."
    else
      echo "✅ You're good, no broken symlinks found in $dir"
    fi
    exit 0
  fi
  deleted=0; updated=0; skipped_count=0
  for link in "${broken_links[@]}"; do
    target=$(readlink "$link"); print_symlink "$link" "$target"
    printf "[d]elete / [u]pdate / [s]kip > "; read -r -n1 action; echo
    case "$action" in
      d|D) if $dry_run; then
             echo -e "${RED}❌ Would delete${RESET}: $link"
           else
             rm -f -- "$link"
             echo -e "${RED}❌ Deleted${RESET}: $link"
           fi
           ((deleted++)) ;;
      u|U) echo "Enter new target path (blank for interactive selection):"; read -r new_target
           [[ -z "$new_target" ]] && new_target=$(select_file "$HOME" "New target")
           if [[ -n "$new_target" ]]; then
             new_target=$(realpath_wrap "$new_target")
              if $dry_run; then
                echo -e "${GREEN}✅ Would update${RESET}: $link -> $new_target"
              else
                ln -sfn -- "$new_target" "$link"
                echo -e "${GREEN}✅ Updated${RESET}: $link -> $new_target"
              fi
             ((updated++))
           else
             echo "⏭️ Skipped: $link"; ((skipped_count++))
           fi ;;
      *) echo "⏭️ Skipped: $link"; ((skipped_count++)) ;;
    esac
  done
  echo -e "📊 Summary: ${RED}${deleted}${RESET} deleted, ${GREEN}${updated}${RESET} updated, ${YELLOW}${skipped_count}${RESET} skipped"
  exit 0
fi

# --- Core Symlink Logic ---
if [[ -n "${1:-}" ]]; then src="$1"; shift
else
  src=$(select_directory "$HOME" 1 5 "Select source directory")
fi
[[ -z "$src" ]] && die "❌ No source selected."

if [[ -n "${1:-}" ]]; then dest="$1"; shift
else
  dest=$(select_directory "$HOME" 0 5 "Select destination directory")
fi
[[ -z "$dest" ]] && die "❌ No destination selected."

src=$(realpath_wrap "$src"); dest=$(realpath_wrap "$dest"); $dry_run || mkdir -p -- "$dest"
linkname=$(basename -- "$src"); target="$dest/$linkname"

if [[ -e "$target" || -L "$target" ]]; then
  if [[ -z "$mode" ]]; then printf "⚠️  %s exists.\n[o]verwrite / [m]erge / [c]ancel > " "$target"; read -r -n1 choice; echo
    case "$choice" in o|O) mode="overwrite";; m|M) mode="merge";; *) die "❌ Cancelled.";; esac
  fi
else mode="overwrite"; fi

if [[ "$mode" == "overwrite" ]]; then
  $dry_run || { rm -rf -- "$target"; ln -s -- "$src" "$target"; }
  $dry_run && echo -e "${RED}🔄 Would overwrite:${RESET} $target → $src" || echo -e "${RED}🔄 Overwritten:${RESET} $target → $src"
fi

if [[ "$mode" == "merge" ]]; then
  mkdir -p -- "$target"; overwrite_all=false
  merge_output=$(find_wrap "$src" -print0 2>&1)
  has_permission_errors=false
  if check_permission_errors "$merge_output"; then has_permission_errors=true; fi
  mapfile -d '' items < <(echo "$merge_output" | grep -v "Permission denied" | tr '\n' '\0')
  for item in "${items[@]}"; do [[ "$item" == "$src" ]] && continue
    rel="${item#"$src"/}"; dest_item="$target/$rel"
    if [[ -d "$item" ]]; then $dry_run || mkdir -p -- "$dest_item"
    else
       if [[ -e "$dest_item" || -L "$dest_item" ]]; then
         if $dry_run; then
           if $dry_run_overwrite; then echo -e "${RED}🔄 Would overwrite:${RESET} $dest_item"
           else echo -e "${YELLOW}⏭️ Would skip:${RESET} $dest_item"; fi
         else
           if $overwrite_all; then
             rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; echo -e "${RED}🔄 Overwritten (all):${RESET} $dest_item"; ((overwritten++))
           else
             printf "⚠️  Conflict: %s exists.\n[s]kip / [o]verwrite / [a]ll overwrite / [c]ancel > " "$dest_item"
             read -r -n1 action; echo
             case "$action" in
               s|S) echo -e "${YELLOW}⏭️ Skipped:${RESET} $dest_item"; ((skipped++)) ;;
               o|O) rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; echo -e "${RED}🔄 Overwritten:${RESET} $dest_item"; ((overwritten++)) ;;
               a|A) overwrite_all=true; rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; echo -e "${RED}🔄 Overwritten (all):${RESET} $dest_item"; ((overwritten++)) ;;
               *) die "❌ Cancelled." ;;
             esac
           fi
         fi
      else
        if $dry_run; then
          echo -e "${GREEN}✅ Would link:${RESET} $dest_item"
          ((linked++))
        else
          ln -s -- "$item" "$dest_item"
          echo -e "${GREEN}✅ Linked:${RESET} $dest_item"
        fi
      fi
    fi
  done
fi

# --- End Output ---
if $dry_run; then
  echo -e "(${YELLOW}Dry run:${RESET} no changes applied)"
  echo -e "📊 Summary: ${GREEN}${linked}${RESET} would link, ${RED}${overwritten}${RESET} would overwrite, ${YELLOW}${skipped}${RESET} would skip"
elif [[ "$show_tree" == true || "$show_tree_verbose" == true ]]; then
  dir="$dest"
  if command -v tree >/dev/null 2>&1; then
    if [[ "$show_tree_verbose" == true ]]; then
      echo "📂 Tree view of $dir (verbose, depth=$depth):"; tree -L "$depth" -F -p "$dir"
    else
      echo "📂 Tree view of $dir (depth=$depth):"; tree -L "$depth" -F "$dir"
    fi
  else
    echo "⚠️ tree not found, falling back to flat symlink list."
    end_tree_output=$(find_wrap "$dir" -maxdepth "$depth" -type l 2>&1)
    check_permission_errors "$end_tree_output" >/dev/null || true  # Just show warning, don't store result
    echo "$end_tree_output" | grep -v "Permission denied" | while read -r l; do
      print_symlink "$l" "$(readlink "$l")"
    done | sort_results
  fi
fi

