#!/usr/bin/env bash
# symlinkit - A flexible symlink helper with fzf + dry-run support
#
# 📌 Usage:
#   symlinkit [FLAGS] [SOURCE] [DESTINATION]
#
# 🔑 Flags:
#   -o                     Overwrite mode (remove existing target, replace with symlink)
#   -m                     Merge mode (recursively symlink contents into destination)
#   --dry-run              Preview actions (conflicts default to "skip")
#   --dry-run-overwrite    Preview actions (conflicts default to "overwrite")
#   --tree                 Minimal tree view (standalone or after linking)
#   --tree-verbose         Verbose tree view with permissions (standalone or after linking)
#
#   --list [DIR]           List symlinks (default: $HOME)
#   --broken [DIR]         List only broken symlinks (default: $HOME)
#   --overview [DIR]       Show symlink overview (symlinks only; tree if installed; fallback to flat) (default: $HOME)
#   --count-only [DIR]     Show only the count of symlinks (default: $HOME)
#   --depth N              Limit overview/tree/fix-broken depth (default: 3)
#   --sort [path|target]   Sort results by path or target
#   --json                 Output results in JSON format
#   --fix-broken [DIR]     Interactively fix broken symlinks (delete / update) (default: $HOME)
#
#   -h, --help             Show help message
#   -v, --version          Show version info
#
VERSION="1.3.0"

# --- Detect OS (Linux, macOS, WSL) ---
case "$(uname -s)" in
  Linux*)   OS="Linux" ;;
  Darwin*)  OS="macOS" ;;
  CYGWIN*|MINGW*|MSYS*) OS="WindowsLike" ;;
  *)        OS="Unknown" ;;
esac

IS_WSL=false
if [[ "$OS" == "Linux" ]] && { [[ -n "${WSL_DISTRO_NAME:-}" ]] || grep -qiE "(microsoft|wsl)" /proc/version 2>/dev/null; }; then
  IS_WSL=true
fi

# --- Dependencies ---
if ! command -v fzf >/dev/null 2>&1; then
  echo "❌ fzf not found. Install with your package manager."
  exit 1
fi

# --- Colors (cyan path, magenta target) ---
PATH_COLOR="\033[0;36m"   # Cyan
TARGET_COLOR="\033[0;35m" # Magenta
RED="\033[0;31m"
YELLOW="\033[0;33m"
GREEN="\033[0;32m"
RESET="\033[0m"

# --- Helpers ---
die() { echo -e "$@" >&2; exit 1; }

realpath_wrap() {
  local p="$1"
  if [[ "$p" == "~"* ]]; then
    p="${p/#\~/$HOME}"
  fi
  if $IS_WSL && [[ "$p" =~ ^[A-Za-z]:\\|\\|/mnt/[a-z]/ ]]; then
    if command -v wslpath >/dev/null 2>&1; then
      p="${p//\\//}"
      wslpath -u "$p"
      return
    fi
  fi
  if command -v realpath >/dev/null 2>&1; then
    realpath -m -- "$p"
  elif [[ "$OS" == "macOS" ]] && command -v grealpath >/dev/null 2>&1; then
    grealpath -m -- "$p"
  elif command -v python3 >/dev/null 2>&1; then
    python3 -c "import os,sys; print(os.path.realpath(sys.argv[1]))" "$p"
  else
    die "❌ Could not resolve path '$p'. Install coreutils (realpath/grealpath) or ensure python3 is available."
  fi
}

find_wrap() {
  if [[ "$OS" == "macOS" ]] && command -v gfind >/dev/null 2>&1; then
    gfind "$@"
  else
    find "$@"
  fi
}

trap "echo; die '❌ Cancelled by user'" SIGINT

# --- Modes ---
dry_run=false
dry_run_overwrite=false
mode=""
show_tree=false
show_tree_verbose=false
list_mode=false
broken_mode=false
overview_mode=false
count_only=false
json=false
sort_by=""
depth=3
fix_broken=false

linked=0
overwritten=0
skipped=0

# --- Parse Flags ---
while [[ "$1" == -* ]]; do
  case "$1" in
    --dry-run) dry_run=true ;;
    --dry-run-overwrite) dry_run=true; dry_run_overwrite=true ;;
    --tree) show_tree=true ;;
    --tree-verbose) show_tree_verbose=true ;;
    -o) mode="overwrite" ;;
    -m) mode="merge" ;;
    --list) list_mode=true ;;
    --broken) broken_mode=true ;;
    --overview) overview_mode=true ;;
    --count-only) count_only=true ;;
    --json) json=true ;;
    --sort) shift; sort_by="$1" ;;
    --depth) shift; depth="$1" ;;
    --fix-broken) fix_broken=true ;;
    -h|--help)
      grep '^# ' "$0" | sed 's/^# //'
      exit 0 ;;
    -v|--version)
      echo "symlinkit $VERSION ($OS${IS_WSL:++WSL})"
      exit 0 ;;
    *) die "❌ Unknown flag: $1" ;;
  esac
  shift
done

# --- Helpers ---
sort_results() {
  case "$sort_by" in
    path) sort ;;
    target) awk -F' -> ' '{print $2, $0}' | sort | cut -d' ' -f2- ;;
    *) cat ;;
  esac
}

print_symlink() {
  local path="$1" target="$2"
  [[ -n "$target" ]] && target=$(realpath_wrap "$target" 2>/dev/null || echo "$target")
  echo -e "${PATH_COLOR}${path}${RESET} -> ${TARGET_COLOR}${target}${RESET}"
}

print_symlink_json() {
  local path="$1" target="$2"
  [[ -n "$target" ]] && target=$(realpath_wrap "$target" 2>/dev/null || echo "$target")
  printf '{"path":"%s","target":"%s"}\n' "$path" "$target"
}

# --- List Symlinks ---
if [[ "$list_mode" == true ]]; then
  dir="${1:-$HOME}"
  if [[ -n "$1" && -d "$1" ]]; then shift; fi
  if $json; then
    find_wrap "$dir" -type l 2>/dev/null | while read -r l; do
      print_symlink_json "$l" "$(readlink "$l")"
    done | sort_results | jq -s .
  else
    count=$(find_wrap "$dir" -type l 2>/dev/null | wc -l)
    echo "📊 Found symlinks in $dir: $count"
    find_wrap "$dir" -type l 2>/dev/null | while read -r l; do
      print_symlink "$l" "$(readlink "$l")"
    done | sort_results
  fi
  exit 0
fi

# --- Broken Symlinks ---
if [[ "$broken_mode" == true ]]; then
  dir="${1:-$HOME}"
  if [[ -n "$1" && -d "$1" ]]; then shift; fi
  if $json; then
    find_wrap "$dir" -type l 2>/dev/null | while read -r l; do
      [[ ! -e "$l" ]] && print_symlink_json "$l" "$(readlink "$l")"
    done | sort_results | jq -s .
  else
    count=$(find_wrap "$dir" -type l 2>/dev/null | while read -r l; do [[ ! -e "$l" ]] && echo "$l"; done | wc -l)
    echo "📊 Found broken symlinks in $dir: $count"
    find_wrap "$dir" -type l 2>/dev/null | while read -r l; do
      [[ ! -e "$l" ]] && print_symlink "$l" "$(readlink "$l")"
    done | sort_results
  fi
  exit 0
fi

# --- Count Only ---
if [[ "$count_only" == true ]]; then
  dir="${1:-$HOME}"
  if [[ -n "$1" && -d "$1" ]]; then shift; fi
  count=$(find_wrap "$dir" -type l 2>/dev/null | wc -l)
  echo "🔢 Symlink count in $dir: $count"
  exit 0
fi

# --- Overview (symlinks only) ---
if [[ "$overview_mode" == true ]]; then
  dir="${1:-$HOME}"
  if [[ -n "$1" && -d "$1" ]]; then shift; fi
  if command -v tree >/dev/null 2>&1; then
    if $json; then
      find_wrap "$dir" -maxdepth "$depth" -type l 2>/dev/null | while read -r l; do
        print_symlink_json "$l" "$(readlink "$l")"
      done | sort_results | jq -s .
    else
      echo "📂 Symlink overview of $dir (depth=$depth):"
      tree -L "$depth" -F -p "$dir" | awk 'NR==1{print;next} /->/'
    fi
  else
    echo "⚠️ tree not found, falling back to flat list."
    find_wrap "$dir" -maxdepth "$depth" -type l 2>/dev/null | while read -r l; do
      print_symlink "$l" "$(readlink "$l")"
    done | sort_results
  fi
  exit 0
fi

# --- Tree Standalone Modes ---
if [[ ("$show_tree" == true || "$show_tree_verbose" == true) && -z "$mode" && "$list_mode" == false && "$broken_mode" == false && "$overview_mode" == false && "$count_only" == false && "$fix_broken" == false ]]; then
  dir="${1:-$HOME}"
  if [[ -n "$1" && -d "$1" ]]; then shift; fi
  if command -v tree >/dev/null 2>&1; then
    if [[ "$show_tree_verbose" == true ]]; then
      echo "📂 Verbose tree view of $dir (depth=$depth):"
      tree -L "$depth" -F -p "$dir"
    else
      echo "📂 Tree view of $dir (depth=$depth):"
      tree -L "$depth" -F "$dir"
    fi
  else
    die "❌ tree command not found. Install it with your package manager."
  fi
  exit 0
fi

# --- Fix Broken Symlinks (interactive) ---
if [[ "$fix_broken" == true ]]; then
  dir="${1:-$HOME}"
  if [[ -n "$1" && -d "$1" ]]; then shift; fi

  mapfile -t broken_links < <(find_wrap "$dir" -type l 2>/dev/null | while read -r l; do [[ ! -e "$l" ]] && echo "$l"; done)

  if [[ "${#broken_links[@]}" -eq 0 ]]; then
    echo "✅ No broken symlinks in $dir"
    exit 0
  fi

  deleted=0
  updated=0
  skipped_count=0

  for link in "${broken_links[@]}"; do
    target=$(readlink "$link")
    print_symlink "$link" "$target"
    printf "[d]elete / [u]pdate / [s]kip > "
    read -r -n1 action; echo

    case "$action" in
      d|D)
        if $dry_run; then
          echo -e "${RED}❌ Would delete${RESET}: $link"
        else
          rm -f -- "$link" && echo -e "${RED}❌ Deleted${RESET}: $link"
        fi
        ((deleted++))
        ;;
      u|U)
        echo "Enter new target path (leave blank to pick with fzf):"
        read -r new_target
        if [[ -z "$new_target" ]]; then
          new_target=$(find_wrap "${SYMLINK_BASE_SRC:-$HOME}" -mindepth 0 -maxdepth "$depth" 2>/dev/null | fzf --prompt="New target> " || true)
        fi
        if [[ -n "$new_target" ]]; then
          new_target=$(realpath_wrap "$new_target")
          if $dry_run; then
            echo -e "${GREEN}✅ Would update${RESET}: $link -> $new_target"
          else
            ln -sfn -- "$new_target" "$link" && echo -e "${GREEN}✅ Updated${RESET}: $link -> $new_target"
          fi
          ((updated++))
        else
          echo "⏭️ Skipped: $link"
          ((skipped_count++))
        fi
        ;;
      *)
        echo "⏭️ Skipped: $link"
        ((skipped_count++))
        ;;
    esac
  done

  echo -e "📊 Summary: ${RED}$deleted deleted${RESET}, ${GREEN}$updated updated${RESET}, ${YELLOW}$skipped_count skipped${RESET}"
  exit 0
fi

# --- Core Symlink Logic ---
if [[ -n "$1" ]]; then
  src="$1"; shift
else
  src=$(find_wrap "${SYMLINK_BASE_SRC:-$HOME}" -mindepth 1 -maxdepth "${SYMLINK_DEPTH:-5}" -type d -print 2>/dev/null \
        | fzf --prompt="Source dir> " --preview 'ls -la --color=always {}' --preview-window=down:15)
fi
[[ -z "$src" ]] && die "❌ No source selected."

if [[ -n "$1" ]]; then
  dest="$1"; shift
else
  dest=$(find_wrap "${SYMLINK_BASE_DEST:-$HOME}" -mindepth 0 -maxdepth "${SYMLINK_DEPTH:-5}" -type d -print 2>/dev/null \
         | fzf --prompt="Destination dir> " --preview 'ls -la --color=always {}' --preview-window=down:15)
fi
[[ -z "$dest" ]] && die "❌ No destination selected."

src=$(realpath_wrap "$src")
dest=$(realpath_wrap "$dest")

$dry_run || mkdir -p -- "$dest"

linkname=$(basename -- "$src")
target="$dest/$linkname"

if [[ -e "$target" || -L "$target" ]]; then
  if [[ -z "$mode" ]]; then
    printf "⚠️  %s already exists.\n[o]verwrite / [m]erge / [c]ancel > " "$target"
    read -r -n1 choice; echo
    case "$choice" in
      o|O) mode="overwrite" ;;
      m|M) mode="merge" ;;
      *) die "❌ Cancelled." ;;
    esac
  fi
else
  mode="overwrite"
fi

# --- Overwrite Mode ---
if [[ "$mode" == "overwrite" ]]; then
  $dry_run || { rm -rf -- "$target"; ln -s -- "$src" "$target"; }
  if $dry_run; then
    echo -e "${RED}🔄 Would overwrite symlink:${RESET} $target → $src"
    ((overwritten++))
  else
    echo -e "${RED}🔄 Overwritten symlink:${RESET} $target → $src"
  fi
fi

# --- Merge Mode ---
if [[ "$mode" == "merge" ]]; then
  mkdir -p -- "$target"
  overwrite_all=false
  mapfile -d '' items < <(find_wrap "$src" -print0)
  for item in "${items[@]}"; do
    [[ "$item" == "$src" ]] && continue
    relpath="${item#$src/}"
    dest_item="$target/$relpath"

    if [[ -d "$item" ]]; then
      $dry_run || mkdir -p -- "$dest_item"
    else
      if [[ -e "$dest_item" || -L "$dest_item" ]]; then
        if [[ "$overwrite_all" == true ]]; then
          $dry_run || { rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; }
          echo -e "${RED}🔄 Overwritten:${RESET} $dest_item"
          ((overwritten++))
        else
          if $dry_run; then
            if $dry_run_overwrite; then
              echo -e "${RED}🔄 Would overwrite:${RESET} $dest_item"
              ((overwritten++))
            else
              echo -e "${YELLOW}⏭️ Would skip:${RESET} $dest_item"
              ((skipped++))
            fi
          else
            printf "⚠️  Conflict: %s exists.\n[s]kip / [o]verwrite / [a]ll overwrite / [c]ancel > " "$dest_item"
            read -r -n1 action; echo
            case "$action" in
              s|S) echo -e "${YELLOW}⏭️ Skipped:${RESET} $dest_item"; ((skipped++)) ;;
              o|O) rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; echo -e "${RED}🔄 Overwritten:${RESET} $dest_item"; ((overwritten++)) ;;
              a|A) overwrite_all=true; rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; echo -e "${RED}🔄 Overwritten (all):${RESET} $dest_item"; ((overwritten++)) ;;
              *) die "❌ Cancelled." ;;
            esac
          fi
        fi
      else
        $dry_run || ln -s -- "$item" "$dest_item"
        if $dry_run; then
          echo -e "${GREEN}✅ Would link:${RESET} $dest_item"
          ((linked++))
        else
          echo -e "${GREEN}✅ Linked:${RESET} $dest_item"
        fi
      fi
    fi
  done
fi

# --- End Output ---
if $dry_run; then
  echo -e "(${YELLOW}Dry run:${RESET} no changes applied)"
  echo -e "📊 Summary: ${GREEN}$linked would link${RESET}, ${RED}$overwritten would overwrite${RESET}, ${YELLOW}$skipped would skip${RESET}"
elif $show_tree || $show_tree_verbose; then
  if command -v tree >/dev/null 2>&1; then
    if [[ "$show_tree_verbose" == true ]]; then
      echo "📂 Destination listing (verbose):"
      tree -L "$depth" -F -p "$dest"
    else
      echo "📂 Destination listing:"
      tree -L "$depth" -F "$dest"
    fi
  else
    echo "❌ tree not found. Install with your package manager."
  fi
fi

