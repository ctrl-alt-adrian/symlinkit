#!/usr/bin/env bash
# symlinkit - A flexible symlink helper with fzf + dry-run support
#
# üìå Usage:
#   symlinkit [FLAGS] [SOURCE] [DESTINATION]
#
# üîë Flags:
#   -o                     Overwrite mode (remove existing target, replace with symlink)
#   -m                     Merge mode (recursively symlink contents into destination)
#   --dry-run              Preview actions (conflicts default to "skip")
#   --dry-run-overwrite    Preview actions (conflicts default to "overwrite")
#   --tree                 Show final destination tree (requires 'tree' installed)
#
#   --list [DIR]           List symlinks (default: $HOME)
#   --broken [DIR]         List only broken symlinks (default: $HOME)
#   --overview [DIR]       Show symlink overview (tree if installed, fallback to find)
#   --count-only [DIR]     Show only the count of symlinks
#   --depth N              Limit overview depth (default: 3)
#   --sort [path|target]   Sort results by path or target
#   --json                 Output results in JSON format
#
# üí° Examples:
#   symlinkit -o ~/dotfiles/config ~/.config
#   symlinkit --list --sort target
#   symlinkit --json --broken /etc
#   symlinkit --overview ~ --depth 2 --json
#   symlinkit --count-only ~
#

VERSION="1.1"

# --- Colors ---
GREEN="\033[0;32m"
RED="\033[0;31m"
YELLOW="\033[0;33m"
RESET="\033[0m"
BOLD="\033[1m"

# --- Defaults ---
dry_run=false
dry_run_overwrite=false
mode=""
show_tree=false
list_mode=""
json_output=false
sort_field=""
depth=3
search_path=""

linked=0
overwritten=0
skipped=0

# --- Help Function ---
show_help() {
  echo -e "${BOLD}${GREEN}symlinkit${RESET} - A flexible symlink helper with fzf + dry-run support"
  echo
  echo -e "${YELLOW}Usage:${RESET}"
  echo "  symlinkit [FLAGS] [SOURCE] [DESTINATION]"
  echo
  echo -e "${YELLOW}Flags:${RESET}"
  cat <<EOF
  -o                     Overwrite mode (remove existing target, replace with symlink)
  -m                     Merge mode (recursively symlink contents into destination)
  --dry-run              Preview actions (conflicts default to "skip")
  --dry-run-overwrite    Preview actions (conflicts default to "overwrite")
  --tree                 Show final destination tree (requires 'tree')

  --list [DIR]           List symlinks (default: \$HOME)
  --broken [DIR]         List only broken symlinks (default: \$HOME)
  --overview [DIR]       Show symlink overview (tree if installed, fallback to find)
  --count-only [DIR]     Show only the count of symlinks
  --depth N              Limit overview depth (default: 3)
  --sort [path|target]   Sort results by path or target
  --json                 Output results in JSON format

  -h, --help             Show this help message
  -v, --version          Show version number
EOF
  echo
  echo -e "${YELLOW}Examples:${RESET}"
  cat <<EOF
  symlinkit -o ~/dotfiles/config ~/.config
  symlinkit --list --sort target
  symlinkit --json --broken /etc
  symlinkit --overview ~ --depth 2 --json
  symlinkit --count-only ~
EOF
}

# --- Pre-flight checks ---
if ! command -v fzf >/dev/null 2>&1; then
  echo "‚ùå fzf not found. Install it: sudo pacman -S fzf"
  exit 1
fi
if ! command -v realpath >/dev/null 2>&1; then
  echo "‚ùå realpath not found. Install coreutils."
  exit 1
fi

# --- Parse flags ---
while [[ "$1" == -* ]]; do
  case "$1" in
    --dry-run) dry_run=true ;;
    --dry-run-overwrite) dry_run=true; dry_run_overwrite=true ;;
    -o) mode="overwrite" ;;
    -m) mode="merge" ;;
    --tree) show_tree=true ;;
    --list) list_mode="all"; shift; search_path="${1:-$HOME}"; [[ "$search_path" == -* ]] && search_path="$HOME" && set -- "$@" ;;
    --broken) list_mode="broken"; shift; search_path="${1:-$HOME}"; [[ "$search_path" == -* ]] && search_path="$HOME" && set -- "$@" ;;
    --overview) list_mode="overview"; shift; search_path="${1:-$HOME}"; [[ "$search_path" == -* ]] && search_path="$HOME" && set -- "$@" ;;
    --count-only) list_mode="count"; shift; search_path="${1:-$HOME}"; [[ "$search_path" == -* ]] && search_path="$HOME" && set -- "$@" ;;
    --depth) shift; depth="$1" ;;
    --sort) shift; sort_field="$1" ;;
    --json) json_output=true ;;
    -v|--version) echo "symlinkit $VERSION"; exit 0 ;;
    -h|--help) show_help; exit 0 ;;
    *) echo "‚ùå Unknown flag: $1"; exit 1 ;;
  esac
  shift
done

# --- Helper: format results into JSON object ---
to_json() {
  local results="$1"
  local count
  count=$(echo "$results" | grep -c .)
  local links
  links=$(echo "$results" | awk -F' -> ' '{printf "{\"link\":\"%s\",\"target\":\"%s\"}\n",$1,$2}' | jq -s .)
  jq -n --argjson links "$links" --argjson count "$count" '{count: $count, links: $links}'
}

# --- Handle listing modes ---
if [[ -n "$list_mode" ]]; then
  case "$list_mode" in
    all) results=$(find "$search_path" -type l -printf '%p -> %l\n') ;;
    broken) results=$(find "$search_path" -xtype l -printf '%p -> %l\n') ;;
    overview)
      if command -v tree >/dev/null 2>&1; then
        results=$(tree -lF -L "$depth" "$search_path" | grep '@' | sed 's/.*\(.* -> .*\)/\1/')
      else
        results=$(find "$search_path" -maxdepth "$depth" -type l -printf '%p -> %l\n')
      fi
      ;;
    count) results=$(find "$search_path" -type l -printf '%p -> %l\n') ;;
  esac

  count=$(echo "$results" | grep -c .)

  # Sorting
  if [[ "$sort_field" == "path" ]]; then
    results=$(echo "$results" | sort -k1,1)
  elif [[ "$sort_field" == "target" ]]; then
    results=$(echo "$results" | sort -t'>' -k2,2)
  fi

  # Count-only shortcut
  if [[ "$list_mode" == "count" ]]; then
    if $json_output; then
      jq -n --argjson count "$count" '{count: $count}'
    else
      echo -e "${YELLOW}üìä Found symlinks:${RESET} $count"
    fi
    exit 0
  fi

  if $json_output; then
    to_json "$results"
  else
    echo -e "${YELLOW}üìä Found symlinks:${RESET} $count"
    echo "$results" \
      | fzf --ansi \
            --prompt="Symlinks> " \
            --preview 'ls -l $(echo {} | cut -d" " -f1)' \
            --preview-window=down:15
  fi
  exit 0
fi

# --- If no args at all, show short usage ---
if [[ $# -eq 0 ]]; then
  echo -e "${YELLOW}Usage:${RESET} symlinkit [FLAGS] [SOURCE] [DESTINATION]"
  echo "Try 'symlinkit --help' for more information."
  exit 0
fi

# --- Handle symlink creation workflow ---
if [[ -n "$1" ]]; then
  src="$1"; shift
else
  src=$(find "${SYMLINK_BASE_SRC:-$HOME}" -mindepth 1 -maxdepth "${SYMLINK_DEPTH:-5}" -type d -print 2>/dev/null \
        | fzf --prompt="Source dir> " --preview 'ls -la --color=always {}' --preview-window=down:15)
fi
[[ -z "$src" ]] && echo "‚ùå No source selected." && exit 1

if [[ -n "$1" ]]; then
  dest="$1"; shift
else
  dest=$(find "${SYMLINK_BASE_DEST:-$HOME}" -mindepth 0 -maxdepth "${SYMLINK_DEPTH:-5}" -type d -print 2>/dev/null \
         | fzf --prompt="Destination dir> " --preview 'ls -la --color=always {}' --preview-window=down:15)
fi
[[ -z "$dest" ]] && echo "‚ùå No destination selected." && exit 1

# Expand and absolutize paths
src=$(realpath -m "$(eval echo "$src")")
dest=$(realpath -m "$(eval echo "$dest")")

# Ensure destination exists
$dry_run || mkdir -p -- "$dest"

linkname=$(basename -- "$src")
target="$dest/$linkname"

# If target exists, pick mode interactively (if no flag given)
if [[ -e "$target" || -L "$target" ]]; then
  if [[ -z "$mode" ]]; then
    printf "‚ö†Ô∏è  %s already exists.\n[o]verwrite / [m]erge / [c]ancel > " "$target"
    read -n1 choice; echo
    case "$choice" in
      o|O) mode="overwrite" ;;
      m|M) mode="merge" ;;
      *) echo "‚ùå Cancelled."; exit 1 ;;
    esac
  fi
else
  mode="overwrite"
fi

# --- Overwrite Mode ---
if [[ "$mode" == "overwrite" ]]; then
  $dry_run || { rm -rf -- "$target"; ln -s -- "$src" "$target"; }
  if $dry_run; then
    echo -e "${RED}üîÑ Would overwrite symlink:${RESET} $target ‚Üí $src"
    ((overwritten++))
  else
    echo -e "${RED}üîÑ Overwritten symlink:${RESET} $target ‚Üí $src"
  fi
fi

# --- Merge Mode ---
if [[ "$mode" == "merge" ]]; then
  mkdir -p -- "$target"
  overwrite_all=false
  find "$src" -print0 | while IFS= read -r -d '' item; do
    [[ "$item" == "$src" ]] && continue
    relpath="${item#$src/}"
    dest_item="$target/$relpath"

    if [[ -d "$item" ]]; then
      $dry_run || mkdir -p -- "$dest_item"
    else
      if [[ -e "$dest_item" || -L "$dest_item" ]]; then
        if [[ "$overwrite_all" == true ]]; then
          $dry_run || { rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; }
          echo -e "${RED}üîÑ Overwritten:${RESET} $dest_item"
          ((overwritten++))
        else
          if $dry_run; then
            if $dry_run_overwrite; then
              echo -e "${RED}üîÑ Would overwrite:${RESET} $dest_item"
              ((overwritten++))
            else
              echo -e "${YELLOW}‚è≠Ô∏è Would skip:${RESET} $dest_item"
              ((skipped++))
            fi
          else
            printf "‚ö†Ô∏è  Conflict: %s exists.\n[s]kip / [o]verwrite / [a]ll overwrite / [c]ancel > " "$dest_item"
            read -n1 action; echo
            case "$action" in
              s|S) echo -e "${YELLOW}‚è≠Ô∏è Skipped:${RESET} $dest_item"; ((skipped++)) ;;
              o|O) rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; echo -e "${RED}üîÑ Overwritten:${RESET} $dest_item"; ((overwritten++)) ;;
              a|A) overwrite_all=true; rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; echo -e "${RED}üîÑ Overwritten (all):${RESET} $dest_item"; ((overwritten++)) ;;
              *) echo "‚ùå Cancelled."; exit 1 ;;
            esac
          fi
        fi
      else
        $dry_run || ln -s -- "$item" "$dest_item"
        if $dry_run; then
          echo -e "${GREEN}‚úÖ Would link:${RESET} $dest_item"
          ((linked++))
        else
          echo -e "${GREEN}‚úÖ Linked:${RESET} $dest_item"
        fi
      fi
    fi
  done
fi

# --- End output ---
if $dry_run; then
  echo -e "(${YELLOW}Dry run:${RESET} no changes applied)"
  echo -e "üìä Summary: ${GREEN}$linked would link${RESET}, ${RED}$overwritten would overwrite${RESET}, ${YELLOW}$skipped would skip${RESET}"
elif $show_tree; then
  if command -v tree >/dev/null 2>&1; then
    echo "üìÇ Destination listing:"
    tree -fp "$dest"
  else
    echo "‚ùå tree not found. Install it: sudo pacman -S tree"
  fi
fi

