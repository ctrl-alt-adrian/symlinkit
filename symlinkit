#!/usr/bin/env bash
# symlinkit - A flexible symlink helper with fzf + dry-run support
#
# Usage:
#   symlinkit [FLAGS] [SOURCE] [DESTINATION]
#
# Flags:
#   -c                     Create mode (create a new symlink, fails if destination exists)
#   -o                     Overwrite mode (remove existing file/directory at destination, replace with symlink)
#   -m                     Merge mode (recursively create symlinks for source directory contents into destination)
#   -d                     Delete mode (remove a symlink, does not affect the target it points to)
#   -r, --recursive        Recursive mode (use with -c, -o, or -d)
#                          -cr: create symlinks recursively (same as -m)
#                          -or: overwrite recursively with prompts
#                          -dr: delete symlinks in directory interactively
#   --dry-run              Preview actions (conflicts default to "skip")
#   --dry-run-overwrite    Preview actions (conflicts default to "overwrite")
#   --tree                 Minimal tree view (standalone or after linking)
#   --tree-verbose         Verbose tree view with permissions (standalone or after linking)
#
#   --list [DIR]           List symlinks (interactive if no dir given)
#   --list-verbose [DIR]   List symlinks with permissions (interactive if no dir given)
#   --broken [DIR]         List only broken symlinks (interactive if no dir given)
#   --fix-broken [DIR]     Interactively fix broken symlinks (interactive if no dir given)
#   --count-only [DIR]     Show only the count of symlinks (interactive if no dir given)
#   --depth N              Limit tree/fix-broken depth (default: 3)
#   --sort [path|target]   Sort results by path or target
#   --json                 Output results in JSON format
#
#   --fzf                  Force fzf usage (error if not installed)
#   --no-fzf               Disable fzf, use manual prompts only
#
#   -h, --help             Show help message
#   -v, --version          Show version info
#

# --- configuration ---
VERSION="1.8.3"
readonly DEFAULT_DEPTH=3

# --- os detection ---
case "$(uname -s)" in
  Linux*)   OS="Linux" ;;
  Darwin*)  OS="macOS" ;;
  CYGWIN*|MINGW*|MSYS*) OS="WindowsLike" ;;
  *)        OS="Unknown" ;;
esac

IS_WSL=false
if [[ "$OS" == "Linux" ]] && { [[ -n "${WSL_DISTRO_NAME:-}" ]] || grep -qiE "(microsoft|wsl)" /proc/version 2>/dev/null; }; then
  IS_WSL=true
fi

# --- colors ---
PATH_COLOR="\033[0;36m"
TARGET_COLOR="\033[0;35m"
RED="\033[0;31m"
YELLOW="\033[0;33m"
GREEN="\033[0;32m"
RESET="\033[0m"

# --- global state ---
dry_run=false
dry_run_overwrite=false
mode=""
show_tree=false
show_tree_verbose=false
list_mode=false
list_verbose_mode=false
broken_mode=false
count_only=false
json=false
sort_by=""
depth=$DEFAULT_DEPTH
fix_broken=false
force_fzf=false
force_no_fzf=false
recursive=false

linked=0
overwritten=0
skipped=0

# --- core utilities ---
die() { echo -e "$@" >&2; exit 1; }
has_fzf() { command -v fzf >/dev/null 2>&1; }

trap "echo; die '‚ùå Cancelled by user'" SIGINT

# Cross-platform path resolution with WSL and macOS support
realpath_wrap() {
  local p="$1"
  local result
  if [[ "$p" == "~"* ]]; then p="${p/#\~/$HOME}"; fi
  if $IS_WSL && [[ "$p" =~ ^[A-Za-z]:\\|\\|/mnt/[a-z]/ ]]; then
    if command -v wslpath >/dev/null 2>&1; then
      p="${p//\\/\/}"; wslpath -u "$p"; return
    fi
  fi
  # Check grealpath first on macOS (GNU version), then realpath
  if [[ "$OS" == "macOS" ]] && command -v grealpath >/dev/null 2>&1; then
    result=$(grealpath -m -- "$p" 2>/dev/null) || result="$p"
  elif command -v realpath >/dev/null 2>&1; then
    result=$(realpath -m -- "$p" 2>/dev/null) || result="$p"
  elif command -v python3 >/dev/null 2>&1; then
    result=$(python3 -c "import os,sys; print(os.path.realpath(sys.argv[1]))" "$p" 2>/dev/null) || result="$p"
  else
    result="$p"
  fi
  echo "$result"
}

# Cross-platform find wrapper (uses gfind on macOS if available)
find_wrap() {
  if [[ "$OS" == "macOS" ]] && command -v gfind >/dev/null 2>&1; then gfind "$@"
  else find "$@"; fi
}

# --- path resolution ---
resolve_input_path() {
  local input_path="$1"
  # Handle tilde expansion
  [[ "$input_path" == "~"* ]] && input_path="${input_path/#\~/$HOME}"
  # Convert to absolute path
  realpath_wrap "$input_path" 2>/dev/null || echo "$input_path"
}

# --- permission error handling ---
check_permission_errors() {
  local output="$1"
  local permission_errors
  permission_errors=$(echo "$output" | grep "Permission denied" || true)
  if [[ -n "$permission_errors" ]]; then
    echo "‚ö†Ô∏è Warning: Some directories could not be scanned due to permissions. Results may be incomplete." >&2
    return 0  # Has permission errors
  fi
  return 1  # No permission errors
}

# Unified safe find wrapper that handles permission errors consistently
safe_find() {
  local find_output
  find_output=$(find_wrap "$@" 2>&1)

  # Check for permission errors and warn if found
  local has_permission_errors=false
  if check_permission_errors "$find_output"; then has_permission_errors=true; fi

  # Filter out permission denied errors and return clean results
  echo "$find_output" | grep -v "Permission denied"

  # Return status indicates if there were permission errors
  if $has_permission_errors; then return 0; else return 1; fi
}

# --- input validation ---
validate_directory() { [[ -d "$1" ]]; }
validate_file() { [[ -f "$1" ]]; }

get_validated_input() {
  local prompt="$1"
  local validation_func="$2"
  local error_message="$3"

  while true; do
    printf "%s: " "$prompt" >&2
    if ! read -r user_input; then
      echo >&2; echo "‚ùå No input received" >&2; return 1
    fi

    [[ -z "$user_input" ]] && { echo "‚ùå Please enter a path" >&2; continue; }

    user_input=$(resolve_input_path "$user_input")

    if "$validation_func" "$user_input"; then
      echo "$user_input"; return 0
    else
      echo "‚ùå $error_message '$user_input'. Please try again." >&2
    fi
  done
}

# --- fzf integration ---
use_fzf() {
  if $force_no_fzf; then return 1; fi
  if $force_fzf; then return 0; fi
  has_fzf
}

# Manual directory selection fallback
manual_select_directory() {
  local search_path="$1"
  local mindepth="${2:-0}"
  local maxdepth="${3:-5}"
  local prompt="${4:-Specify a directory}"

  get_validated_input "$prompt" "validate_directory" "Directory does not exist:"
}

# Manual file selection fallback
manual_select_file() {
  local search_path="$1"
  local prompt="${2:-Specify a file}"

  get_validated_input "$prompt" "validate_file" "File does not exist:"
}

# Hybrid directory selection (fzf or manual)
select_directory() {
  local search_path="$1"
  local mindepth="${2:-0}"
  local maxdepth="${3:-5}"
  local prompt="${4:-Select a directory}"

  if use_fzf; then
    find_wrap "$search_path" -mindepth "$mindepth" -maxdepth "$maxdepth" -type d 2>/dev/null \
      | fzf --prompt="$prompt > " --preview 'ls -la --color=always {}' --preview-window=down:15
  else
    # Convert "Select" to "Specify" for manual input
    local manual_prompt="${prompt/Select/Specify}"
    manual_select_directory "$search_path" "$mindepth" "$maxdepth" "$manual_prompt"
  fi
}

# Hybrid file selection (fzf or manual)
select_file() {
  local search_path="$1"
  local prompt="${2:-Select a file}"

  if use_fzf; then
    find_wrap "$search_path" -type f 2>/dev/null | fzf --prompt="$prompt > "
  else
    # Convert "Select" to "Specify" for manual input
    local manual_prompt="${prompt/Select/Specify}"
    manual_select_file "$search_path" "$manual_prompt"
  fi
}

# --- output formatting ---
sort_results() {
  case "$sort_by" in
    path) sort ;;
    target) awk -F' -> ' '{print $2, $0}' | sort | cut -d' ' -f2- ;;
    *) cat ;;
  esac
}

print_symlink() {
  local path="$1" target="$2"
  # Only resolve target if it's not already an absolute path
  # For relative symlink targets, resolve them relative to the symlink's directory
  if [[ -n "$target" && "$target" != /* ]]; then
    local symlink_dir
    symlink_dir="$(dirname "$path")"
    target=$(cd "$symlink_dir" && realpath_wrap "$target" 2>/dev/null || echo "$target")
  fi
  echo -e "${PATH_COLOR}${path}${RESET} -> ${TARGET_COLOR}${target}${RESET}"
}

print_symlink_verbose() { ls -l "$1"; }

print_symlink_json() {
  local path="$1" target="$2"
  # Only resolve target if it's not already an absolute path
  # For relative symlink targets, resolve them relative to the symlink's directory
  if [[ -n "$target" && "$target" != /* ]]; then
    local symlink_dir
    symlink_dir="$(dirname "$path")"
    target=$(cd "$symlink_dir" && realpath_wrap "$target" 2>/dev/null || echo "$target")
  fi
  printf '{"path":"%s","target":"%s"}\n' "$path" "$target"
}


# Count display formatter
display_count() {
  local count="$1"
  local item_type="$2"
  local directory="$3"

  local plural_s=""
  [[ "$count" -ne 1 ]] && plural_s="s"

  echo -e "üìä Found ${GREEN}${count}${RESET} ${item_type}${plural_s} in ${TARGET_COLOR}${directory}${RESET}"
}

# Tree display function
display_tree() {
  local dir="$1"
  local verbose="${2:-false}"
  local depth="${3:-$DEFAULT_DEPTH}"

  if command -v tree >/dev/null 2>&1; then
    local tree_args=(-L "$depth" -F)
    $verbose && tree_args+=(-p)
    local verbose_text=""
    $verbose && verbose_text=" (verbose"
    echo "üìÇ Tree view of $dir${verbose_text}, depth=$depth):"
    tree "${tree_args[@]}" "$dir"
  else
    echo "‚ö†Ô∏è tree not found, falling back to flat symlink list."
    fallback_tree_display "$dir" "$depth"
  fi
}

# Fallback tree display using find
fallback_tree_display() {
  local dir="$1"
  local depth="$2"

  local tree_output
  tree_output=$(safe_find "$dir" -maxdepth "$depth" -type l)
  echo "$tree_output" | while read -r l; do
    print_symlink "$l" "$(readlink "$l")"
  done | sort_results
}

# --- mode handlers ---

# Find operations for different modes
find_all_symlinks() {
  safe_find "$1" -type l
}

find_broken_symlinks() {
  local dir="$1"
  local broken_output
  broken_output=$(safe_find "$dir" -type l)
  local has_permission_errors=$?

  local broken_symlinks
  broken_symlinks=$(echo "$broken_output" | while read -r l; do [[ ! -e "$l" ]] && echo "$l"; done)

  echo "$broken_symlinks"
  return $has_permission_errors
}

# Output handlers for different modes
handle_list_output() {
  local symlinks="$1"
  local dir="$2"
  local has_permission_errors="$3"

  local count
  if [[ -z "$symlinks" || "$symlinks" =~ ^[[:space:]]*$ ]]; then
    count=0
  else
    count=$(echo "$symlinks" | wc -l)
  fi

  [[ "$count" -eq 0 ]] && {
    if [[ "$has_permission_errors" -eq 0 ]]; then
      echo "‚ö†Ô∏è Could not scan all directories due to permissions. No symlinks found in accessible areas."
    else
      echo "‚ùå No symlinks found in this directory"
    fi
    exit 0
  }

  if $json; then
    if command -v jq >/dev/null 2>&1 && echo '[]' | jq . >/dev/null 2>&1; then
      echo "$symlinks" | while read -r l; do print_symlink_json "$l" "$(readlink "$l")"; done | sort_results | jq -s .
    else
      echo "["
      echo "$symlinks" | while read -r l; do print_symlink_json "$l" "$(readlink "$l")"; done | sort_results | sed '$!s/$/,/'
      echo "]"
    fi
  else
    display_count "$count" "symlink" "$dir"
    if [[ "$list_verbose_mode" == true ]]; then
      echo "$symlinks" | while read -r l; do print_symlink_verbose "$l"; done | sort_results
    else
      echo "$symlinks" | while read -r l; do print_symlink "$l" "$(readlink "$l")"; done | sort_results
    fi
  fi
  exit 0
}

handle_broken_output() {
  local broken_symlinks="$1"
  local dir="$2"
  local has_permission_errors="$3"

  local broken_count
  if [[ -z "$broken_symlinks" || "$broken_symlinks" =~ ^[[:space:]]*$ ]]; then
    broken_count=0
  else
    broken_count=$(echo "$broken_symlinks" | wc -l)
  fi

  if [[ "$broken_count" -eq 0 ]]; then
    if [[ "$has_permission_errors" -eq 0 ]]; then
      echo "‚ö†Ô∏è Could not scan all directories due to permissions. No broken symlinks found in accessible areas."
    else
      echo "‚úÖ You're good, no broken symlinks found in $dir"
    fi
    exit 0
  fi

  if $json; then
    if command -v jq >/dev/null 2>&1 && echo '[]' | jq . >/dev/null 2>&1; then
      echo "$broken_symlinks" | while read -r l; do print_symlink_json "$l" "$(readlink "$l")"; done | sort_results | jq -s .
    else
      echo "["
      echo "$broken_symlinks" | while read -r l; do print_symlink_json "$l" "$(readlink "$l")"; done | sort_results | sed '$!s/$/,/'
      echo "]"
    fi
  else
    display_count "$broken_count" "broken symlink" "$dir"
    echo "$broken_symlinks" | while read -r l; do print_symlink "$l" "$(readlink "$l")"; done | sort_results
  fi
  exit 0
}

handle_count_output() {
  local symlinks="$1"
  local dir="$2"
  local has_permission_errors="$3"

  local count
  if [[ -z "$symlinks" || "$symlinks" =~ ^[[:space:]]*$ ]]; then
    count=0
  else
    count=$(echo "$symlinks" | wc -l)
  fi

  if $json; then
    printf '{"directory":"%s","count":%d}\n' "$dir" "$count"
  else
    echo -e "üî¢ ${GREEN}${count}${RESET} symlink$([[ "$count" -ne 1 ]] && echo "s") in ${TARGET_COLOR}${dir}${RESET}"
  fi
  exit 0
}

# --- flag parsing ---
while [[ $# -gt 0 && "$1" == -* ]]; do
  case "$1" in
    --dry-run) dry_run=true ;;
    --dry-run-overwrite) dry_run=true; dry_run_overwrite=true ;;
    --tree) show_tree=true ;;
    --tree-verbose) show_tree_verbose=true ;;
    -c) mode="create" ;;
    -o) mode="overwrite" ;;
    -m) mode="merge" ;;
    -d) mode="delete" ;;
    -r|--recursive) recursive=true ;;
    -cr|-rc) mode="create"; recursive=true ;;
    -or|-ro) mode="overwrite"; recursive=true ;;
    -dr|-rd) mode="delete"; recursive=true ;;
    --list) list_mode=true ;;
    --list-verbose) list_verbose_mode=true ;;
    --broken) broken_mode=true ;;
    --count-only) count_only=true ;;
    --json) json=true ;;
    --sort) shift; sort_by="$1" ;;
    --depth) shift; depth="$1" ;;
    --fix-broken) fix_broken=true ;;
    --fzf) force_fzf=true ;;
    --no-fzf) force_no_fzf=true ;;
    -h|--help) sed -n '2,/^$/p' "$0" | grep '^#' | sed 's/^# \?//' ; exit 0 ;;
    -v|--version) echo "symlinkit $VERSION ($OS${IS_WSL:++WSL})"; exit 0 ;;
    *) die "‚ùå Unknown flag: $1" ;;
  esac; shift
done

# If --json is specified without any mode, default to list mode
if $json && ! $list_mode && ! $list_verbose_mode && ! $broken_mode && ! $count_only && ! $show_tree && ! $show_tree_verbose && ! $fix_broken; then
  list_mode=true
fi

# Validate fzf flags
if $force_fzf && $force_no_fzf; then
  die "‚ùå Cannot use both --fzf and --no-fzf flags together"
fi

if $force_fzf && ! has_fzf; then
  die "‚ùå fzf not found but --fzf flag was specified. Install with your package manager."
fi

# --- mode execution ---

# List / List-Verbose mode
if [[ "$list_mode" == true || "$list_verbose_mode" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    prompt="Select a directory to list symlinks"
    [[ "$list_verbose_mode" == true ]] && prompt+=" (verbose)"
    dir=$(select_directory "$HOME" 0 5 "$prompt")
    [[ -z "$dir" ]] && die "‚ùå No directory selected."
  fi
  find_results=$(find_all_symlinks "$dir")
  has_permission_errors=$?
  handle_list_output "$find_results" "$dir" $has_permission_errors
fi

# Broken symlinks mode
if [[ "$broken_mode" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    dir=$(select_directory "$HOME" 0 5 "Select a directory to check for broken symlinks")
    [[ -z "$dir" ]] && die "‚ùå No directory selected."
  fi
  find_results=$(find_broken_symlinks "$dir")
  has_permission_errors=$?
  handle_broken_output "$find_results" "$dir" $has_permission_errors
fi

# Count only mode
if [[ "$count_only" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    dir=$(select_directory "$HOME" 0 5 "Select a destination directory to count symlinks")
    [[ -z "$dir" ]] && die "‚ùå No directory selected."
  fi
  find_results=$(find_all_symlinks "$dir")
  has_permission_errors=$?
  handle_count_output "$find_results" "$dir" $has_permission_errors
fi

# Tree modes
if [[ "$show_tree" == true || "$show_tree_verbose" == true ]]; then
  dir=""
  if [[ -n "${1:-}" && -d "$1" ]]; then
    dir="$1"
    shift
  else
    dir=$(select_directory "$HOME" 0 5 "Select a directory to display tree")
    [[ -z "$dir" ]] && die "‚ùå No directory selected."
  fi
  display_tree "$dir" "$show_tree_verbose" "$depth"
  exit 0
fi

# Fix broken symlinks mode
if [[ "$fix_broken" == true ]]; then
  dir=""
  if [[ -n "${1:-}" && -d "$1" ]]; then
    dir="$1"
    shift
  else
    dir=$(select_directory "$HOME" 0 5 "Select a directory to fix broken symlinks")
    [[ -z "$dir" ]] && die "‚ùå No directory selected."
  fi

  fix_results=$(find_broken_symlinks "$dir")
  has_permission_errors=$?

  mapfile -t broken_links < <(echo "$fix_results")

  if [[ "${#broken_links[@]}" -eq 0 ]] || [[ -z "${broken_links[0]}" ]]; then
    if [[ "$has_permission_errors" -eq 0 ]]; then
      echo "‚ö†Ô∏è Could not scan all directories due to permissions. No broken symlinks found in accessible areas."
    else
      echo "‚úÖ You're good, no broken symlinks found in $dir"
    fi
    exit 0
  fi

  deleted=0 updated=0 skipped_count=0
  delete_all=false

  for link in "${broken_links[@]}"; do
    [[ -z "$link" ]] && continue
    target=$(readlink "$link")

    if $delete_all; then
      if $dry_run; then
        echo -e "${RED}‚ùå Would delete (all)${RESET}: $link"
      else
        rm -f -- "$link"
        echo -e "${RED}‚ùå Deleted (all)${RESET}: $link"
      fi
      ((deleted++))
      continue
    fi

    print_symlink "$link" "$target"
    printf "[d]elete / [a]ll delete / [u]pdate / [s]kip > "; read -r -n1 action; echo
    case "$action" in
      d|D) if $dry_run; then
             echo -e "${RED}‚ùå Would delete${RESET}: $link"
           else
             rm -f -- "$link"
             echo -e "${RED}‚ùå Deleted${RESET}: $link"
           fi
           ((deleted++)) ;;
      a|A) delete_all=true
           if $dry_run; then
             echo -e "${RED}‚ùå Would delete (all)${RESET}: $link"
           else
             rm -f -- "$link"
             echo -e "${RED}‚ùå Deleted (all)${RESET}: $link"
           fi
           ((deleted++)) ;;
      u|U) echo "Enter new target path (blank for interactive selection):"; read -r new_target
           [[ -z "$new_target" ]] && new_target=$(select_file "$HOME" "New target")
           if [[ -n "$new_target" ]]; then
             new_target=$(realpath_wrap "$new_target")
              if $dry_run; then
                echo -e "${GREEN}‚úÖ Would update${RESET}: $link -> $new_target"
              else
                ln -sfn -- "$new_target" "$link"
                echo -e "${GREEN}‚úÖ Updated${RESET}: $link -> $new_target"
              fi
             ((updated++))
           else
             echo "‚è≠Ô∏è Skipped: $link"; ((skipped_count++))
           fi ;;
      *) echo "‚è≠Ô∏è Skipped: $link"; ((skipped_count++)) ;;
    esac
  done
  echo -e "üìä Summary: ${RED}${deleted}${RESET} deleted, ${GREEN}${updated}${RESET} updated, ${YELLOW}${skipped_count}${RESET} skipped"
  exit 0
fi

# Delete mode
if [[ "$mode" == "delete" ]]; then
  target=""
  if [[ -n "${1:-}" ]]; then
    target="$1"
    shift
  else
    if $recursive; then
      target=$(select_directory "$HOME" 0 5 "Select a directory to delete symlinks from")
    else
      target=$(select_file "$HOME" "Select a symlink to delete")
    fi
  fi

  [[ -z "$target" ]] && die "‚ùå No target selected."

  # Resolve path without following symlinks
  [[ "$target" == "~"* ]] && target="${target/#\~/$HOME}"
  if [[ "$target" != /* ]]; then
    target="$(pwd)/$target"
  fi

  # Recursive delete mode
  if $recursive; then
    [[ ! -d "$target" ]] && die "‚ùå $target is not a directory"

    symlinks_to_delete=$(find_all_symlinks "$target")
    has_permission_errors=$?

    mapfile -t links < <(echo "$symlinks_to_delete")

    if [[ "${#links[@]}" -eq 0 ]] || [[ -z "${links[0]}" ]]; then
      if [[ "$has_permission_errors" -eq 0 ]]; then
        echo "‚ö†Ô∏è Could not scan all directories due to permissions. No symlinks found in accessible areas."
      else
        echo "‚úÖ No symlinks found in $target"
      fi
      exit 0
    fi

    echo "Found ${#links[@]} symlink(s) in $target"
    deleted=0 skipped_count=0
    delete_all=false

    for link in "${links[@]}"; do
      [[ -z "$link" ]] && continue
      link_target=$(readlink "$link")

      if $delete_all; then
        if $dry_run; then
          echo -e "${RED}‚ùå Would delete (all)${RESET}: $link"
        else
          rm -f -- "$link"
          echo -e "${RED}‚ùå Deleted (all)${RESET}: $link"
        fi
        ((deleted++))
        continue
      fi

      print_symlink "$link" "$link_target"
      printf "[d]elete / [a]ll delete / [s]kip / [q]uit > "; read -r -n1 action; echo
      case "$action" in
        d|D) if $dry_run; then
               echo -e "${RED}‚ùå Would delete${RESET}: $link"
             else
               rm -f -- "$link"
               echo -e "${RED}‚ùå Deleted${RESET}: $link"
             fi
             ((deleted++)) ;;
        a|A) delete_all=true
             if $dry_run; then
               echo -e "${RED}‚ùå Would delete (all)${RESET}: $link"
             else
               rm -f -- "$link"
               echo -e "${RED}‚ùå Deleted (all)${RESET}: $link"
             fi
             ((deleted++)) ;;
        q|Q) echo "Exiting..."; break ;;
        *) echo "‚è≠Ô∏è Skipped: $link"; ((skipped_count++)) ;;
      esac
    done

    echo -e "üìä Summary: ${RED}${deleted}${RESET} deleted, ${YELLOW}${skipped_count}${RESET} skipped"
    exit 0
  fi

  # Single file delete mode
  if [[ ! -L "$target" ]]; then
    die "‚ùå $target is not a symlink"
  fi

  link_target=$(readlink "$target")

  if $dry_run; then
    echo -e "${RED}‚ùå Would delete:${RESET} $target ‚Üí $link_target"
  else
    rm -f -- "$target"
    echo -e "${RED}‚ùå Deleted:${RESET} $target ‚Üí $link_target"
  fi
  exit 0
fi

# --- core symlink logic ---
# Check if operation mode is specified before proceeding
if [[ -z "$mode" && -z "${1:-}" ]]; then
  echo "‚ùå No operation specified." >&2
  echo "" >&2
  echo "Available operations:" >&2
  echo "  -c    Create mode (create a new symlink)" >&2
  echo "  -o    Overwrite mode (remove existing target, replace with symlink)" >&2
  echo "  -m    Merge mode (recursively symlink contents into destination)" >&2
  echo "  -d    Delete mode (remove a symlink)" >&2
  echo "" >&2
  echo "Available commands (no operation required):" >&2
  echo "  --list          List symlinks in a directory" >&2
  echo "  --broken        Show broken symlinks" >&2
  echo "  --fix-broken    Interactively fix broken symlinks" >&2
  echo "  --tree          Show tree view" >&2
  echo "  --count-only    Count symlinks" >&2
  echo "  -h, --help      Show help" >&2
  exit 1
fi

if [[ -n "${1:-}" ]]; then src="$1"; shift
else
  src=$(select_directory "$HOME" 1 5 "Select source directory")
fi
[[ -z "$src" ]] && die "‚ùå No source selected."

if [[ -n "${1:-}" ]]; then dest="$1"; shift
else
  dest=$(select_directory "$HOME" 0 5 "Select destination directory")
fi
[[ -z "$dest" ]] && die "‚ùå No destination selected."

src=$(realpath_wrap "$src")
dest=$(realpath_wrap "$dest")
if ! $dry_run; then
  mkdir -p -- "$dest"
fi
linkname=$(basename -- "$src"); target="$dest/$linkname"

if [[ -e "$target" || -L "$target" ]]; then
  if [[ -z "$mode" ]]; then printf "‚ö†Ô∏è  %s exists.\n[o]verwrite / [m]erge / [c]ancel > " "$target"; read -r -n1 choice; echo
    case "$choice" in o|O) mode="overwrite";; m|M) mode="merge";; *) die "‚ùå Cancelled.";; esac
  fi
fi

# Require operation to be specified
if [[ -z "$mode" ]]; then
  die "‚ùå No operation specified. Use -c (create), -o (overwrite), -m (merge), or -d (delete)."
fi

# Convert create/overwrite + recursive to merge mode
merge_overwrite_all=false
if $recursive; then
  if [[ "$mode" == "create" ]]; then
    mode="merge"
  elif [[ "$mode" == "overwrite" ]]; then
    mode="merge"
    merge_overwrite_all=true
  fi
fi

if [[ "$mode" == "create" ]]; then
  if [[ -e "$target" || -L "$target" ]]; then
    die "‚ùå Target already exists: $target\n   Use -o to overwrite or -m to merge into existing target"
  fi

  if ! $dry_run; then
    if ! ln -s -- "$src" "$target" 2>/dev/null; then
      die "‚ùå Failed to create symlink: $target ‚Üí $src\n   Check permissions and path validity"
    fi
  fi

  if $dry_run; then
    echo -e "${GREEN}‚úÖ Would create symlink:${RESET} $target ‚Üí $src"
  else
    echo -e "${GREEN}‚úÖ Successfully created symlink:${RESET} $target ‚Üí $src"
  fi
fi

if [[ "$mode" == "overwrite" ]]; then
  if ! $dry_run; then
    # Security: Only use rm -f for symlinks, rm -rf for directories/files
    if [[ -L "$target" ]]; then
      if ! rm -f -- "$target" 2>/dev/null; then
        die "‚ùå Failed to remove existing symlink: $target\n   Check permissions"
      fi
    else
      if ! rm -rf -- "$target" 2>/dev/null; then
        die "‚ùå Failed to remove existing target: $target\n   Check permissions"
      fi
    fi
    if ! ln -s -- "$src" "$target" 2>/dev/null; then
      die "‚ùå Failed to create symlink after removal: $target ‚Üí $src\n   Check permissions and path validity"
    fi
  fi
  $dry_run && echo -e "${RED}üîÑ Would overwrite:${RESET} $target ‚Üí $src" || echo -e "${RED}üîÑ Overwritten:${RESET} $target ‚Üí $src"
fi

if [[ "$mode" == "merge" ]]; then
  if ! $dry_run; then
    if ! mkdir -p -- "$target" 2>/dev/null; then
      die "‚ùå Failed to create target directory: $target\n   Check permissions"
    fi
  fi
  overwrite_all=$merge_overwrite_all
  merge_output=$(safe_find "$src")
  has_permission_errors=$?
  mapfile -t items < <(echo "$merge_output")
  for item in "${items[@]}"; do [[ -z "$item" || "$item" == "$src" ]] && continue
    rel="${item#"$src"/}"; dest_item="$target/$rel"
    if [[ -d "$item" ]]; then
      if ! $dry_run; then
        if ! mkdir -p -- "$dest_item" 2>/dev/null; then
          echo -e "${RED}‚ö†Ô∏è  Failed to create directory:${RESET} $dest_item (skipping)" >&2
          continue
        fi
      fi
    else
       if [[ -e "$dest_item" || -L "$dest_item" ]]; then
         if $dry_run; then
           if $dry_run_overwrite; then echo -e "${RED}üîÑ Would overwrite:${RESET} $dest_item"
           else echo -e "${YELLOW}‚è≠Ô∏è Would skip:${RESET} $dest_item"; fi
         else
           if $overwrite_all; then
             # Security: Check if target is symlink first
             if [[ -L "$dest_item" ]]; then
               rm -f -- "$dest_item" 2>/dev/null
             else
               rm -rf -- "$dest_item" 2>/dev/null
             fi
             if ln -s -- "$item" "$dest_item" 2>/dev/null; then
               echo -e "${RED}üîÑ Overwritten (all):${RESET} $dest_item"; ((overwritten++))
             else
               echo -e "${RED}‚ö†Ô∏è  Failed to overwrite:${RESET} $dest_item (skipping)" >&2
             fi
           else
             printf "‚ö†Ô∏è  Conflict: %s exists.\n[s]kip / [o]verwrite / [a]ll overwrite / [c]ancel > " "$dest_item"
             read -r -n1 action; echo
             case "$action" in
               s|S) echo -e "${YELLOW}‚è≠Ô∏è Skipped:${RESET} $dest_item"; ((skipped++)) ;;
               o|O) # Security: Check if target is symlink first
                    if [[ -L "$dest_item" ]]; then
                      rm -f -- "$dest_item" 2>/dev/null
                    else
                      rm -rf -- "$dest_item" 2>/dev/null
                    fi
                    if ln -s -- "$item" "$dest_item" 2>/dev/null; then
                      echo -e "${RED}üîÑ Overwritten:${RESET} $dest_item"; ((overwritten++))
                    else
                      echo -e "${RED}‚ö†Ô∏è  Failed to overwrite:${RESET} $dest_item" >&2; ((skipped++))
                    fi ;;
               a|A) overwrite_all=true
                    # Security: Check if target is symlink first
                    if [[ -L "$dest_item" ]]; then
                      rm -f -- "$dest_item" 2>/dev/null
                    else
                      rm -rf -- "$dest_item" 2>/dev/null
                    fi
                    if ln -s -- "$item" "$dest_item" 2>/dev/null; then
                      echo -e "${RED}üîÑ Overwritten (all):${RESET} $dest_item"; ((overwritten++))
                    else
                      echo -e "${RED}‚ö†Ô∏è  Failed to overwrite:${RESET} $dest_item" >&2; ((skipped++))
                    fi ;;
               *) die "‚ùå Cancelled." ;;
             esac
           fi
         fi
      else
        if $dry_run; then
          echo -e "${GREEN}‚úÖ Would link:${RESET} $dest_item"
          ((linked++))
        else
          if ln -s -- "$item" "$dest_item" 2>/dev/null; then
            echo -e "${GREEN}‚úÖ Linked:${RESET} $dest_item"
            ((linked++))
          else
            echo -e "${RED}‚ö†Ô∏è  Failed to link:${RESET} $dest_item" >&2
          fi
        fi
      fi
    fi
  done
fi

# --- end output ---
if $dry_run; then
  echo -e "(${YELLOW}Dry run:${RESET} no changes applied)"
  echo -e "üìä Summary: ${GREEN}${linked}${RESET} would link, ${RED}${overwritten}${RESET} would overwrite, ${YELLOW}${skipped}${RESET} would skip"
elif [[ "$show_tree" == true || "$show_tree_verbose" == true ]]; then
  display_tree "$dest" "$show_tree_verbose" "$depth"
fi
