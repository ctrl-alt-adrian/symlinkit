#!/usr/bin/env bash
# symlinkit - A flexible symlink helper with fzf + dry-run support
#
# 📌 Usage:
#   symlinkit [FLAGS] [SOURCE] [DESTINATION]
#
# 🔑 Flags:
#   -o                     Overwrite mode (remove existing target, replace with symlink)
#   -m                     Merge mode (recursively symlink contents into destination)
#   --dry-run              Preview actions (conflicts default to "skip")
#   --dry-run-overwrite    Preview actions (conflicts default to "overwrite")
#   --tree                 Show final destination tree (requires 'tree' installed)
#
#   --list [DIR]           List symlinks (default: $HOME)
#   --broken [DIR]         List only broken symlinks (default: $HOME)
#   --overview [DIR]       Show symlink overview (tree if installed, fallback to find) (default: $HOME)
#   --count-only [DIR]     Show only the count of symlinks (default: $HOME)
#   --depth N              Limit overview depth (default: 3)
#   --sort [path|target]   Sort results by path or target
#   --json                 Output results in JSON format
#
#   -h, --help             Show help message
#   -v, --version          Show version info
#
# 💡 Examples:
#   symlinkit -o ~/dotfiles/config ~/.config
#   symlinkit --list
#   symlinkit --list /etc
#   symlinkit --list /
#   symlinkit --json --broken
#   symlinkit --overview ~ --depth 2 --json
#   symlinkit --count-only ~
#
VERSION="1.1.1"

# --- Dependencies ---
if ! command -v fzf >/dev/null 2>&1; then
  echo "❌ fzf not found. Install with: sudo pacman -S fzf"
  exit 1
fi

if ! command -v realpath >/dev/null 2>&1; then
  echo "❌ realpath not found. Install coreutils."
  exit 1
fi

# --- Colors ---
GREEN="\033[0;32m"
RED="\033[0;31m"
YELLOW="\033[0;33m"
RESET="\033[0m"

# --- Modes ---
dry_run=false
dry_run_overwrite=false
mode=""
show_tree=false
list_mode=false
broken_mode=false
overview_mode=false
count_only=false
json=false
sort_by=""
depth=3

linked=0
overwritten=0
skipped=0

# --- Parse Flags ---
while [[ "$1" == -* ]]; do
  case "$1" in
    --dry-run) dry_run=true ;;
    --dry-run-overwrite) dry_run=true; dry_run_overwrite=true ;;
    --tree) show_tree=true ;;
    -o) mode="overwrite" ;;
    -m) mode="merge" ;;
    --list) list_mode=true ;;
    --broken) broken_mode=true ;;
    --overview) overview_mode=true ;;
    --count-only) count_only=true ;;
    --json) json=true ;;
    --sort) shift; sort_by="$1" ;;
    --depth) shift; depth="$1" ;;
    -h|--help)
      grep '^# ' "$0" | sed 's/^# //'
      exit 0 ;;
    -v|--version)
      echo "symlinkit $VERSION"
      exit 0 ;;
    *) echo "❌ Unknown flag: $1"; exit 1 ;;
  esac
  shift
done

# --- Helper: Sort Results ---
sort_results() {
  case "$sort_by" in
    path) sort ;;
    target) awk '{print $NF, $0}' | sort | cut -d' ' -f2- ;;
    *) cat ;;
  esac
}

# --- List Symlinks ---
if [[ "$list_mode" == true ]]; then
  dir="${1:-$HOME}"
  if [[ -n "$1" && -d "$1" ]]; then shift; fi
  if $json; then
    find "$dir" -type l -printf '{"path":"%p","target":"%l"}\n' 2>/dev/null \
      | sort_results | jq -s .
  else
    count=$(find "$dir" -type l 2>/dev/null | wc -l)
    echo "📊 Found symlinks in $dir: $count"
    find "$dir" -type l -ls 2>/dev/null | sort_results
  fi
  exit 0
fi

# --- Broken Symlinks ---
if [[ "$broken_mode" == true ]]; then
  dir="${1:-$HOME}"
  if [[ -n "$1" && -d "$1" ]]; then shift; fi
  if $json; then
    find "$dir" -xtype l -printf '{"path":"%p","target":"%l"}\n' 2>/dev/null \
      | sort_results | jq -s .
  else
    count=$(find "$dir" -xtype l 2>/dev/null | wc -l)
    echo "📊 Found broken symlinks in $dir: $count"
    find "$dir" -xtype l -ls 2>/dev/null | sort_results
  fi
  exit 0
fi

# --- Count Only ---
if [[ "$count_only" == true ]]; then
  dir="${1:-$HOME}"
  if [[ -n "$1" && -d "$1" ]]; then shift; fi
  count=$(find "$dir" -type l 2>/dev/null | wc -l)
  echo "🔢 Symlink count in $dir: $count"
  exit 0
fi

# --- Overview Mode ---
if [[ "$overview_mode" == true ]]; then
  dir="${1:-$HOME}"
  if [[ -n "$1" && -d "$1" ]]; then shift; fi
  if command -v tree >/dev/null 2>&1; then
    if $json; then
      find "$dir" -maxdepth "$depth" -type l -printf '{"path":"%p","target":"%l"}\n' \
        2>/dev/null | sort_results | jq -s .
    else
      echo "📂 Symlink overview of $dir (depth=$depth):"
      tree -L "$depth" -F -p -l -P '*' "$dir"
    fi
  else
    echo "⚠️ tree not found, falling back to flat list."
    find "$dir" -maxdepth "$depth" -type l -ls 2>/dev/null | sort_results
  fi
  exit 0
fi

# --- Core Symlink Logic (overwrite/merge, unchanged) ---
# Expand arguments
if [[ -n "$1" ]]; then
  src="$1"; shift
else
  src=$(find "${SYMLINK_BASE_SRC:-$HOME}" -mindepth 1 -maxdepth "${SYMLINK_DEPTH:-5}" -type d -print 2>/dev/null \
        | fzf --prompt="Source dir> " --preview 'ls -la --color=always {}' --preview-window=down:15)
fi
[[ -z "$src" ]] && echo "❌ No source selected." && exit 1

if [[ -n "$1" ]]; then
  dest="$1"; shift
else
  dest=$(find "${SYMLINK_BASE_DEST:-$HOME}" -mindepth 0 -maxdepth "${SYMLINK_DEPTH:-5}" -type d -print 2>/dev/null \
         | fzf --prompt="Destination dir> " --preview 'ls -la --color=always {}' --preview-window=down:15)
fi
[[ -z "$dest" ]] && echo "❌ No destination selected." && exit 1

src=$(realpath -m "$(eval echo "$src")")
dest=$(realpath -m "$(eval echo "$dest")")

$dry_run || mkdir -p -- "$dest"

linkname=$(basename -- "$src")
target="$dest/$linkname"

# Conflict handling
if [[ -e "$target" || -L "$target" ]]; then
  if [[ -z "$mode" ]]; then
    printf "⚠️  %s already exists.\n[o]verwrite / [m]erge / [c]ancel > " "$target"
    read -n1 choice; echo
    case "$choice" in
      o|O) mode="overwrite" ;;
      m|M) mode="merge" ;;
      *) echo "❌ Cancelled."; exit 1 ;;
    esac
  fi
else
  mode="overwrite"
fi

# --- Overwrite Mode ---
if [[ "$mode" == "overwrite" ]]; then
  $dry_run || { rm -rf -- "$target"; ln -s -- "$src" "$target"; }
  if $dry_run; then
    echo -e "${RED}🔄 Would overwrite symlink:${RESET} $target → $src"
    ((overwritten++))
  else
    echo -e "${RED}🔄 Overwritten symlink:${RESET} $target → $src"
  fi
fi

# --- Merge Mode ---
if [[ "$mode" == "merge" ]]; then
  mkdir -p -- "$target"
  overwrite_all=false
  find "$src" -print0 | while IFS= read -r -d '' item; do
    [[ "$item" == "$src" ]] && continue
    relpath="${item#$src/}"
    dest_item="$target/$relpath"

    if [[ -d "$item" ]]; then
      $dry_run || mkdir -p -- "$dest_item"
    else
      if [[ -e "$dest_item" || -L "$dest_item" ]]; then
        if [[ "$overwrite_all" == true ]]; then
          $dry_run || { rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; }
          echo -e "${RED}🔄 Overwritten:${RESET} $dest_item"
          ((overwritten++))
        else
          if $dry_run; then
            if $dry_run_overwrite; then
              echo -e "${RED}🔄 Would overwrite:${RESET} $dest_item"
              ((overwritten++))
            else
              echo -e "${YELLOW}⏭️ Would skip:${RESET} $dest_item"
              ((skipped++))
            fi
          else
            printf "⚠️  Conflict: %s exists.\n[s]kip / [o]verwrite / [a]ll overwrite / [c]ancel > " "$dest_item"
            read -n1 action; echo
            case "$action" in
              s|S) echo -e "${YELLOW}⏭️ Skipped:${RESET} $dest_item"; ((skipped++)) ;;
              o|O) rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; echo -e "${RED}🔄 Overwritten:${RESET} $dest_item"; ((overwritten++)) ;;
              a|A) overwrite_all=true; rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; echo -e "${RED}🔄 Overwritten (all):${RESET} $dest_item"; ((overwritten++)) ;;
              *) echo "❌ Cancelled."; exit 1 ;;
            esac
          fi
        fi
      else
        $dry_run || ln -s -- "$item" "$dest_item"
        if $dry_run; then
          echo -e "${GREEN}✅ Would link:${RESET} $dest_item"
          ((linked++))
        else
          echo -e "${GREEN}✅ Linked:${RESET} $dest_item"
        fi
      fi
    fi
  done
fi

# --- End Summary ---
if $dry_run; then
  echo -e "(${YELLOW}Dry run:${RESET} no changes applied)"
  echo -e "📊 Summary: ${GREEN}$linked would link${RESET}, ${RED}$overwritten would overwrite${RESET}, ${YELLOW}$skipped would skip${RESET}"
elif $show_tree; then
  if command -v tree >/dev/null 2>&1; then
    echo "📂 Destination listing:"
    tree -fp "$dest"
  else
    echo "❌ Tree not found. Install with: sudo pacman -S tree"
  fi
fi

