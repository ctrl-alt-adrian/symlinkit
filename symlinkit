#!/usr/bin/env bash
# symlinkit - A flexible symlink helper with fzf + dry-run support
#
# ðŸ“Œ Usage:
#   symlinkit [FLAGS] [SOURCE] [DESTINATION]
#
# ðŸ”‘ Flags:
#   -o                     Overwrite mode (remove existing target, replace with symlink)
#   -m                     Merge mode (recursively symlink contents into destination)
#   --dry-run              Preview actions (conflicts default to "skip")
#   --dry-run-overwrite    Preview actions (conflicts default to "overwrite")
#   --tree                 Minimal tree view (standalone or after linking)
#   --tree-verbose         Verbose tree view with permissions (standalone or after linking)
#
#   --list [DIR]           List symlinks (interactive if no dir given)
#   --list-verbose [DIR]   List symlinks with permissions (interactive if no dir given)
#   --broken [DIR]         List only broken symlinks (interactive if no dir given)
#   --fix-broken [DIR]     Interactively fix broken symlinks (interactive if no dir given)
#   --count-only [DIR]     Show only the count of symlinks (interactive if no dir given)
#   --depth N              Limit tree/fix-broken depth (default: 3)
#   --sort [path|target]   Sort results by path or target
#   --json                 Output results in JSON format
#
#   -h, --help             Show help message
#   -v, --version          Show version info
#
VERSION="1.4.1"

# --- Detect OS (Linux, macOS, WSL) ---
case "$(uname -s)" in
  Linux*)   OS="Linux" ;;
  Darwin*)  OS="macOS" ;;
  CYGWIN*|MINGW*|MSYS*) OS="WindowsLike" ;;
  *)        OS="Unknown" ;;
esac

IS_WSL=false
if [[ "$OS" == "Linux" ]] && { [[ -n "${WSL_DISTRO_NAME:-}" ]] || grep -qiE "(microsoft|wsl)" /proc/version 2>/dev/null; }; then
  IS_WSL=true
fi

# --- Dependencies ---
if ! command -v fzf >/dev/null 2>&1; then
  echo "âŒ fzf not found. Install with your package manager."
  exit 1
fi

# --- Colors ---
PATH_COLOR="\033[0;36m"
TARGET_COLOR="\033[0;35m"
RED="\033[0;31m"
YELLOW="\033[0;33m"
GREEN="\033[0;32m"
RESET="\033[0m"

# --- Helpers ---
# Error reporting and exit function
die() { echo -e "$@" >&2; exit 1; }

# Cross-platform path resolution with WSL and macOS support
realpath_wrap() {
  local p="$1"
  if [[ "$p" == "~"* ]]; then p="${p/#\~/$HOME}"; fi
  if $IS_WSL && [[ "$p" =~ ^[A-Za-z]:\\|\\|/mnt/[a-z]/ ]]; then
    if command -v wslpath >/dev/null 2>&1; then
      p="${p//\\/\/}"; wslpath -u "$p"; return
    fi
  fi
  if command -v realpath >/dev/null 2>&1; then realpath -m -- "$p"
  elif [[ "$OS" == "macOS" ]] && command -v grealpath >/dev/null 2>&1; then grealpath -m -- "$p"
  elif command -v python3 >/dev/null 2>&1; then python3 -c "import os,sys; print(os.path.realpath(sys.argv[1]))" "$p"
  else die "âŒ Could not resolve path '$p'."; fi
}

# Cross-platform find wrapper (uses gfind on macOS if available)
find_wrap() {
  if [[ "$OS" == "macOS" ]] && command -v gfind >/dev/null 2>&1; then gfind "$@"
  else find "$@"; fi
}

trap "echo; die 'âŒ Cancelled by user'" SIGINT

# Check for permission errors and display warning
check_permission_errors() {
  local output="$1"
  local permission_errors
  permission_errors=$(echo "$output" | grep "Permission denied" || true)
  if [[ -n "$permission_errors" ]]; then
    echo "âš ï¸ Warning: Some directories could not be scanned due to permissions. Results may be incomplete." >&2
    return 0  # Has permission errors
  fi
  return 1  # No permission errors
}

# Safe find wrapper that handles permission errors consistently
safe_find() {
  local find_output
  find_output=$(find_wrap "$@" 2>&1)

  # Check for permission errors and warn if found
  local has_permission_errors=false
  if check_permission_errors "$find_output"; then has_permission_errors=true; fi

  # Filter out permission denied errors and return clean results
  echo "$find_output" | grep -v "Permission denied"

  # Return status indicates if there were permission errors
  if $has_permission_errors; then return 0; else return 1; fi
}

# Safe find wrapper for null-separated output (used in merge mode)
safe_find_print0() {
  local find_output
  find_output=$(find_wrap "$@" 2>&1)

  # Check for permission errors and warn if found
  local has_permission_errors=false
  if check_permission_errors "$find_output"; then has_permission_errors=true; fi

  # Filter out permission denied errors and return clean results
  # Note: find -print0 produces null-separated output, so we preserve that
  echo "$find_output" | grep -v "Permission denied"

  # Return status indicates if there were permission errors
  if $has_permission_errors; then return 0; else return 1; fi
}

# --- Modes ---
dry_run=false
dry_run_overwrite=false
mode=""
show_tree=false
show_tree_verbose=false
list_mode=false
list_verbose_mode=false
broken_mode=false
count_only=false
json=false
sort_by=""
depth=3
fix_broken=false

linked=0
overwritten=0
skipped=0

# --- Parse Flags ---
while [[ $# -gt 0 && "$1" == -* ]]; do
  case "$1" in
    --dry-run) dry_run=true ;;
    --dry-run-overwrite) dry_run=true; dry_run_overwrite=true ;;
    --tree) show_tree=true ;;
    --tree-verbose) show_tree_verbose=true ;;
    -o) mode="overwrite" ;;
    -m) mode="merge" ;;
    --list) list_mode=true ;;
    --list-verbose) list_verbose_mode=true ;;
    --broken) broken_mode=true ;;
    --count-only) count_only=true ;;
    --json) json=true ;;
    --sort) shift; sort_by="$1" ;;
    --depth) shift; depth="$1" ;;
    --fix-broken) fix_broken=true ;;
    -h|--help) grep '^# ' "$0" | sed 's/^# //' ; exit 0 ;;
    -v|--version) echo "symlinkit $VERSION ($OS${IS_WSL:++WSL})"; exit 0 ;;
    *) die "âŒ Unknown flag: $1" ;;
  esac; shift
done

# If --json is specified without any mode, default to list mode
if $json && ! $list_mode && ! $list_verbose_mode && ! $broken_mode && ! $count_only && ! $show_tree && ! $show_tree_verbose && ! $fix_broken; then
  list_mode=true
fi

# --- Helpers ---
sort_results() {
  case "$sort_by" in
    path) sort ;;
    target) awk -F' -> ' '{print $2, $0}' | sort | cut -d' ' -f2- ;;
    *) cat ;;
  esac
}
print_symlink() {
  local path="$1" target="$2"
  [[ -n "$target" ]] && target=$(realpath_wrap "$target" 2>/dev/null || echo "$target")
  echo -e "${PATH_COLOR}${path}${RESET} -> ${TARGET_COLOR}${target}${RESET}"
}
print_symlink_verbose() { ls -l "$1"; }
print_symlink_json() {
  local path="$1" target="$2"
  [[ -n "$target" ]] && target=$(realpath_wrap "$target" 2>/dev/null || echo "$target")
  printf '{"path":"%s","target":"%s"}\n' "$path" "$target"
}

# --- List / List-Verbose ---
if [[ "$list_mode" == true || "$list_verbose_mode" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    prompt="Select a directory to list symlinks"
    [[ "$list_verbose_mode" == true ]] && prompt+=" (verbose)"
    dir=$(find_wrap "$HOME" -mindepth 0 -maxdepth 5 -type d 2>/dev/null \
          | fzf --prompt="$prompt > " --preview 'ls -la --color=always {}' --preview-window=down:15)
    [[ -z "$dir" ]] && die "âŒ No directory selected."
  fi
  list_output=$(find_wrap "$dir" -type l 2>&1)
  has_permission_errors=false
  if check_permission_errors "$list_output"; then has_permission_errors=true; fi
  symlinks=$(echo "$list_output" | grep -v "Permission denied")
  count=$(echo "$symlinks" | wc -l)
  [[ "$count" -eq 0 ]] && {
    if $has_permission_errors; then
      echo "âš ï¸ Could not scan all directories due to permissions. No symlinks found in accessible areas."
    else
      echo "âŒ No symlinks found in this directory"
    fi
    exit 0
  }
  if $json; then
    if command -v jq >/dev/null 2>&1; then
      echo "$symlinks" | while read -r l; do print_symlink_json "$l" "$(readlink "$l")"; done | sort_results | jq -s .
    else
      echo "["
      echo "$symlinks" | while read -r l; do print_symlink_json "$l" "$(readlink "$l")"; done | sort_results | sed '$!s/$/,/'
      echo "]"
    fi
  else
    if [[ "$count" -eq 1 ]]; then
      echo -e "ðŸ“Š Found ${GREEN}1${RESET} symlink in ${TARGET_COLOR}${dir}${RESET}:"
    else
      echo -e "ðŸ“Š Found ${GREEN}${count}${RESET} symlinks in ${TARGET_COLOR}${dir}${RESET}:"
    fi
    if [[ "$list_verbose_mode" == true ]]; then
      echo "$symlinks" | while read -r l; do print_symlink_verbose "$l"; done | sort_results
    else
      echo "$symlinks" | while read -r l; do print_symlink "$l" "$(readlink "$l")"; done | sort_results
    fi
  fi; exit 0
fi

# --- Broken ---
if [[ "$broken_mode" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    dir=$(find_wrap "$HOME" -mindepth 0 -maxdepth 5 -type d 2>/dev/null \
          | fzf --prompt="Select a directory to check for broken symlinks > " --preview 'ls -la --color=always {}' --preview-window=down:15)
    [[ -z "$dir" ]] && die "âŒ No directory selected."
  fi
  broken_output=$(find_wrap "$dir" -type l 2>&1)
  has_permission_errors=false
  if check_permission_errors "$broken_output"; then has_permission_errors=true; fi
  broken_symlinks=$(echo "$broken_output" | grep -v "Permission denied" | while read -r l; do [[ ! -e "$l" ]] && echo "$l"; done)
  broken_count=$(echo "$broken_symlinks" | wc -l)
  if [[ "$broken_count" -eq 0 ]]; then
    if $has_permission_errors; then
      echo "âš ï¸ Could not scan all directories due to permissions. No broken symlinks found in accessible areas."
    else
      echo "âœ… You're good, no broken symlinks found in $dir"
    fi
    exit 0
  fi
  if $json; then
    if command -v jq >/dev/null 2>&1; then
      echo "$broken_symlinks" | while read -r l; do print_symlink_json "$l" "$(readlink "$l")"; done | sort_results | jq -s .
    else
      echo "["
      echo "$broken_symlinks" | while read -r l; do print_symlink_json "$l" "$(readlink "$l")"; done | sort_results | sed '$!s/$/,/'
      echo "]"
    fi
  else
    if [[ "$broken_count" -eq 1 ]]; then
      echo -e "ðŸ“Š Found ${GREEN}1${RESET} broken symlink in ${TARGET_COLOR}${dir}${RESET}"
    else
      echo -e "ðŸ“Š Found ${GREEN}${broken_count}${RESET} broken symlinks in ${TARGET_COLOR}${dir}${RESET}"
    fi
    echo "$broken_symlinks" | while read -r l; do print_symlink "$l" "$(readlink "$l")"; done | sort_results
  fi
  exit 0
fi

# --- Count Only ---
if [[ "$count_only" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    dir=$(find_wrap "$HOME" -mindepth 0 -maxdepth 5 -type d 2>/dev/null \
          | fzf --prompt="Select a destination directory to count symlinks > " --preview 'ls -la --color=always {}' --preview-window=down:15)
    [[ -z "$dir" ]] && die "âŒ No directory selected."
  fi
  count_output=$(find_wrap "$dir" -type l 2>&1)
  has_permission_errors=false
  if check_permission_errors "$count_output"; then has_permission_errors=true; fi
  count=$(echo "$count_output" | grep -c -v "Permission denied")
  if $json; then
    printf '{"directory":"%s","count":%d}\n' "$dir" "$count"
  else
    if [[ "$count" -eq 1 ]]; then
      echo -e "ðŸ”¢ ${GREEN}1${RESET} symlink in ${TARGET_COLOR}${dir}${RESET}"
    else
      echo -e "ðŸ”¢ ${GREEN}${count}${RESET} symlinks in ${TARGET_COLOR}${dir}${RESET}"
    fi
  fi
  exit 0
fi

# --- Tree / Tree-Verbose ---
if [[ "$show_tree" == true || "$show_tree_verbose" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    prompt="Select a directory to display tree"
    [[ "$show_tree_verbose" == true ]] && prompt+=" (verbose)"
    dir=$(find_wrap "$HOME" -mindepth 0 -maxdepth 5 -type d 2>/dev/null \
          | fzf --prompt="$prompt > " --preview 'ls -la --color=always {}' --preview-window=down:15)
    [[ -z "$dir" ]] && die "âŒ No directory selected."
  fi
  if command -v tree >/dev/null 2>&1; then
    if [[ "$show_tree_verbose" == true ]]; then
      echo "ðŸ“‚ Tree view of $dir (verbose, depth=$depth):"; tree -L "$depth" -F -p "$dir"
    else
      echo "ðŸ“‚ Tree view of $dir (depth=$depth):"; tree -L "$depth" -F "$dir"
    fi
  else
    echo "âš ï¸ tree not found, falling back to flat symlink list."
    tree_output=$(find_wrap "$dir" -maxdepth "$depth" -type l 2>&1)
    check_permission_errors "$tree_output" >/dev/null || true  # Just show warning, don't store result
    echo "$tree_output" | grep -v "Permission denied" | while read -r l; do print_symlink "$l" "$(readlink "$l")"; done | sort_results
  fi; exit 0
fi

# --- Fix Broken ---
if [[ "$fix_broken" == true ]]; then
  if [[ -n "${1:-}" && -d "$1" ]]; then dir="$1"; shift
  else
    dir=$(find_wrap "$HOME" -mindepth 0 -maxdepth 5 -type d 2>/dev/null \
          | fzf --prompt="Select a directory to fix broken symlinks > " --preview 'ls -la --color=always {}' --preview-window=down:15)
    [[ -z "$dir" ]] && die "âŒ No directory selected."
  fi
  fix_output=$(find_wrap "$dir" -type l 2>&1)
  has_permission_errors=false
  if check_permission_errors "$fix_output"; then has_permission_errors=true; fi
  mapfile -t broken_links < <(echo "$fix_output" | grep -v "Permission denied" | while read -r l; do [[ ! -e "$l" ]] && echo "$l"; done)
  if [[ "${#broken_links[@]}" -eq 0 ]]; then
    if $has_permission_errors; then
      echo "âš ï¸ Could not scan all directories due to permissions. No broken symlinks found in accessible areas."
    else
      echo "âœ… You're good, no broken symlinks found in $dir"
    fi
    exit 0
  fi
  deleted=0; updated=0; skipped_count=0
  for link in "${broken_links[@]}"; do
    target=$(readlink "$link"); print_symlink "$link" "$target"
    printf "[d]elete / [u]pdate / [s]kip > "; read -r -n1 action; echo
    case "$action" in
      d|D) if $dry_run; then
             echo -e "${RED}âŒ Would delete${RESET}: $link"
           else
             rm -f -- "$link"
             echo -e "${RED}âŒ Deleted${RESET}: $link"
           fi
           ((deleted++)) ;;
      u|U) echo "Enter new target path (blank to pick with fzf):"; read -r new_target
           [[ -z "$new_target" ]] && new_target=$(find_wrap "$HOME" -type f | fzf --prompt="New target > ")
           if [[ -n "$new_target" ]]; then
             new_target=$(realpath_wrap "$new_target")
              if $dry_run; then
                echo -e "${GREEN}âœ… Would update${RESET}: $link -> $new_target"
              else
                ln -sfn -- "$new_target" "$link"
                echo -e "${GREEN}âœ… Updated${RESET}: $link -> $new_target"
              fi
             ((updated++))
           else
             echo "â­ï¸ Skipped: $link"; ((skipped_count++))
           fi ;;
      *) echo "â­ï¸ Skipped: $link"; ((skipped_count++)) ;;
    esac
  done
  echo -e "ðŸ“Š Summary: ${RED}${deleted}${RESET} deleted, ${GREEN}${updated}${RESET} updated, ${YELLOW}${skipped_count}${RESET} skipped"
  exit 0
fi

# --- Core Symlink Logic ---
if [[ -n "${1:-}" ]]; then src="$1"; shift
else
  src=$(find_wrap "$HOME" -mindepth 1 -maxdepth 5 -type d | fzf --prompt="Source dir > " --preview 'ls -la --color=always {}')
fi
[[ -z "$src" ]] && die "âŒ No source selected."

if [[ -n "${1:-}" ]]; then dest="$1"; shift
else
  dest=$(find_wrap "$HOME" -mindepth 0 -maxdepth 5 -type d | fzf --prompt="Destination dir > " --preview 'ls -la --color=always {}')
fi
[[ -z "$dest" ]] && die "âŒ No destination selected."

src=$(realpath_wrap "$src"); dest=$(realpath_wrap "$dest"); $dry_run || mkdir -p -- "$dest"
linkname=$(basename -- "$src"); target="$dest/$linkname"

if [[ -e "$target" || -L "$target" ]]; then
  if [[ -z "$mode" ]]; then printf "âš ï¸  %s exists.\n[o]verwrite / [m]erge / [c]ancel > " "$target"; read -r -n1 choice; echo
    case "$choice" in o|O) mode="overwrite";; m|M) mode="merge";; *) die "âŒ Cancelled.";; esac
  fi
else mode="overwrite"; fi

if [[ "$mode" == "overwrite" ]]; then
  $dry_run || { rm -rf -- "$target"; ln -s -- "$src" "$target"; }
  $dry_run && echo -e "${RED}ðŸ”„ Would overwrite:${RESET} $target â†’ $src" || echo -e "${RED}ðŸ”„ Overwritten:${RESET} $target â†’ $src"
fi

if [[ "$mode" == "merge" ]]; then
  mkdir -p -- "$target"; overwrite_all=false
  merge_output=$(find_wrap "$src" -print0 2>&1)
  has_permission_errors=false
  if check_permission_errors "$merge_output"; then has_permission_errors=true; fi
  mapfile -d '' items < <(echo "$merge_output" | grep -v "Permission denied" | tr '\n' '\0')
  for item in "${items[@]}"; do [[ "$item" == "$src" ]] && continue
    rel="${item#"$src"/}"; dest_item="$target/$rel"
    if [[ -d "$item" ]]; then $dry_run || mkdir -p -- "$dest_item"
    else
       if [[ -e "$dest_item" || -L "$dest_item" ]]; then
         if $dry_run; then
           if $dry_run_overwrite; then echo -e "${RED}ðŸ”„ Would overwrite:${RESET} $dest_item"
           else echo -e "${YELLOW}â­ï¸ Would skip:${RESET} $dest_item"; fi
         else
           if $overwrite_all; then
             rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; echo -e "${RED}ðŸ”„ Overwritten (all):${RESET} $dest_item"; ((overwritten++))
           else
             printf "âš ï¸  Conflict: %s exists.\n[s]kip / [o]verwrite / [a]ll overwrite / [c]ancel > " "$dest_item"
             read -r -n1 action; echo
             case "$action" in
               s|S) echo -e "${YELLOW}â­ï¸ Skipped:${RESET} $dest_item"; ((skipped++)) ;;
               o|O) rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; echo -e "${RED}ðŸ”„ Overwritten:${RESET} $dest_item"; ((overwritten++)) ;;
               a|A) overwrite_all=true; rm -rf -- "$dest_item"; ln -s -- "$item" "$dest_item"; echo -e "${RED}ðŸ”„ Overwritten (all):${RESET} $dest_item"; ((overwritten++)) ;;
               *) die "âŒ Cancelled." ;;
             esac
           fi
         fi
      else
        if $dry_run; then
          echo -e "${GREEN}âœ… Would link:${RESET} $dest_item"
          ((linked++))
        else
          ln -s -- "$item" "$dest_item"
          echo -e "${GREEN}âœ… Linked:${RESET} $dest_item"
        fi
      fi
    fi
  done
fi

# --- End Output ---
if $dry_run; then
  echo -e "(${YELLOW}Dry run:${RESET} no changes applied)"
  echo -e "ðŸ“Š Summary: ${GREEN}${linked}${RESET} would link, ${RED}${overwritten}${RESET} would overwrite, ${YELLOW}${skipped}${RESET} would skip"
elif [[ "$show_tree" == true || "$show_tree_verbose" == true ]]; then
  dir="$dest"
  if command -v tree >/dev/null 2>&1; then
    if [[ "$show_tree_verbose" == true ]]; then
      echo "ðŸ“‚ Tree view of $dir (verbose, depth=$depth):"; tree -L "$depth" -F -p "$dir"
    else
      echo "ðŸ“‚ Tree view of $dir (depth=$depth):"; tree -L "$depth" -F "$dir"
    fi
  else
    echo "âš ï¸ tree not found, falling back to flat symlink list."
    end_tree_output=$(find_wrap "$dir" -maxdepth "$depth" -type l 2>&1)
    check_permission_errors "$end_tree_output" >/dev/null || true  # Just show warning, don't store result
    echo "$end_tree_output" | grep -v "Permission denied" | while read -r l; do
      print_symlink "$l" "$(readlink "$l")"
    done | sort_results
  fi
fi

